e = "text/worker" > on("sheet:opened", eventinfo => { pfom.sheet_open(eventinfo) }),
    on("clicked:mancer_confirm", () => { setAttrs({ mancer_confirm_flag: "0", charactermancer_step: "l1-welcome" }, { silent: !0 }, () => { pfom.check_l1_mancer() }) }), on("clicked:mancer_npc", () => { setAttrs({ npc: "1", mancer_confirm_flag: "0", l1mancer_status: "completed" }, { silent: !0 }) }), on("clicked:mancer_cancel", () => { setAttrs({ mancer_confirm_flag: "0", l1mancer_status: "completed" }, { silent: !0 }) }), on("mancer:cancel", eventinfo => {
        if (!eventinfo.value) return;
        let update = {};
        "spell-cancel" == eventinfo.value ? (console.dir(eventinfo), update.pcdrop_name = "", update.pcdrop_uniq = "", update.pcdrop_category = "", update.pcdrop_data = "", update.pcdrop_content = "", update.l1mancer_status = "completed", update.charactermancer_step = "l1-welcome", deleteCharmancerData(["spell-choose"])) : "l1-welcome" === eventinfo.value || "l1-cancel" === eventinfo.value ? (update.l1mancer_status = "completed", update.charactermancer_step = "l1-welcome", deleteCharmancerData(["l1-welcome", "l1-abilities", "l1-race", "l1-class", "l1-feats", "l1-equipment", "l1-spells", "l1-summary"])) : "l1-" === eventinfo.value.substring(0, 3) && (update.l1mancer_status = eventinfo.value), setAttrs(update)
    }), on("clicked:cancel", () => { showChoices(["cancel-prompt"]) }), on("clicked:continue", () => { hideChoices(["cancel-prompt"]) }), on("mancerfinish:l1-mancer", eventinfo => { pfom.mancer_finish(eventinfo) }), on("clicked:relaunch_lvl1mancer", eventinfo => {
        getAttrs(["l1mancer_status"], v => {
            let update = {};
            "completed" === v.l1mancer_status && (update.l1mancer_status = "relaunch"), setAttrs(update, { silent: !0 }, () => { pfom.check_l1_mancer() })
        })
    }), on("mancerfinish:spell-choose", eventinfo => {
        finishCharactermancer();
        let level = "0", caster = "1";
        eventinfo.data && eventinfo.data["spell-choose"] && eventinfo.data["spell-choose"].values && eventinfo.data["spell-choose"].values.spell_level && (level = eventinfo.data["spell-choose"].values.spell_level), eventinfo.data && eventinfo.data["spell-choose"] && eventinfo.data["spell-choose"].values && eventinfo.data["spell-choose"].values.spell_class && (caster = eventinfo.data["spell-choose"].values.spell_class), pfom.pc_drop_spell(level, caster)
    }), on("clicked:le_big_stuff", () => { pfom.le_big_stuff("all") }), on("clicked:rest", () => {
        getSectionIDs("abilities", abarray => {
            getSectionIDs("spell-like", splarray => {
                if (abarray.length || splarray.length) {
                    let fields = ["setting_maxrest"];
                    fields.push(...abarray.map(id => `repeating_abilities_${id}_perday_max`)), fields.push(...splarray.map(id => `repeating_spell-like_${id}_perday_max`)), getAttrs(fields, v => {
                        let update = {}, setmax = parseInt(v.setting_maxrest) || 0;
                        abarray.map(abid => update[`repeating_abilities_${abid}_perday`] = 1 == setmax && parseInt(v[`repeating_abilities_${abid}_perday_max`]) || 0), splarray.map(splid => update[`repeating_spell-like_${splid}_perday`] = 1 == setmax && parseInt(v[`repeating_spell-like_${splid}_perday_max`]) || 0), setAttrs(update, { silent: !0 })
                    })
                }
            })
        })
    }), on("change:pcdrop_data", e => {
        if ((!e.triggerType || e.triggerType && "compendium" == e.triggerType) && e && e.newValue) {
            let cdata;
            try { cdata = JSON.parse(e.newValue) || {} } catch (error) { cdata = {} } _.isEmpty(cdata) ? console.log("*** DEBUG change:pcdrop_data: empty data") : pfom.pc_drop_handler(cdata)
        }
    }), on("change:strength_base change:strength_race change:strength_bonus change:strength_condition", () => { pfom.le_big_stuff("strength") }), on("change:dexterity_base change:dexterity_race change:dexterity_bonus change:dexterity_condition", () => { pfom.le_big_stuff("dexterity") }), on("change:constitution_base change:constitution_race change:constitution_bonus", () => { pfom.le_big_stuff("constitution") }), on("change:intelligence_base change:intelligence_race change:intelligence_bonus", () => { pfom.le_big_stuff("intelligence") }), on("change:wisdom_base change:wisdom_race change:wisdom_bonus", () => { pfom.le_big_stuff("wisdom") }), on("change:charisma_base change:charisma_race change:charisma_bonus", () => { pfom.le_big_stuff("charisma") }), on("change:strength", () => { pfom.update_mod("strength") }), on("change:dexterity", () => { pfom.update_mod("dexterity") }), on("change:constitution", () => { pfom.update_mod("constitution") }), on("change:intelligence", () => { pfom.update_mod("intelligence") }), on("change:wisdom", () => { pfom.update_mod("wisdom") }), on("change:charisma", () => { pfom.update_mod("charisma") }), on("change:size", e => { pfom.update_size(e.newValue) }), on("change:encumbrance_size", () => { pfom.update_encumbrance() }), on("change:hp", e => {
        getAttrs(["npc", "hp", "hp_max", "hp_condition", "hp_bonus"], v => {
            if ("1" != v.npc) "player" == e.sourceType && setAttrs({ hp_base: (parseInt(v.hp) || 0) - (parseInt(v.hp_condition) || 0) - (parseInt(v.hp_bonus) || 0) }, { silent: !0 });
            else {
                var newv = parseInt(e.newValue) || 0;
                newv > 0 && (parseInt(v.hp_max) || 0) < newv && setAttrs({ hp_max: newv }, { silent: !0 })
            }
        })
    }), on("change:hp_max", e => { "player" == e.sourceType && getAttrs(["npc", "hp_max", "hp_base_max", "hp_condition", "hp_bonus"], v => { "1" != v.npc && setAttrs({ hp_base_max: (parseInt(v.hp_max) || 0) - (parseInt(v.hp_condition) || 0) - (parseInt(v.hp_bonus) || 0) }, { silent: !0 }) }) }), on("change:hp_condition change:hp_bonus", e => {
        var oldv, newv;
        oldv = parseInt(e.previousValue) || 0, (newv = parseInt(e.newValue) || 0) != oldv && getAttrs(["npc", "hp_base", "hp_base_max", "hp_condition", "hp_bonus"], v => {
            if ("1" != v.npc) {
                var update = {};
                update.hp = (parseInt(v.hp_base) || 0) + newv, update.hp_max = (parseInt(v.hp_base_max) || 0) + newv, update.hp_mod = (parseInt(v.hp_condition) || 0) + (parseInt(v.hp_bonus) || 0), parseInt(update.hp_mod) > 0 ? update.hp_mod_flag = 2 : parseInt(update.hp_mod) < 0 ? update.hp_mod_flag = 1 : update.hp_mod_flag = 0, setAttrs(update, { silent: !0 })
            }
        })
    }), on("change:class_favored change:class1_hitdietype change:class2_hitdietype change:class3_hitdietype", () => { pfom.update_hitdie() }), on("change:class1_name change:class2_name change:class3_name change:caster1_flag change:caster2_flag", e => { pfom.update_class_names(e.sourceAttribute) }), on("change:class1_level change:class2_level change:class3_level", e => { pfom.update_class_numbers("level"), pfom.update_skillranks_total() }), on("change:class1_bab change:class2_bab change:class3_bab", e => { pfom.update_class_numbers("bab") }), on("change:class1_fortitude change:class2_fortitude change:class3_fortitude", e => { pfom.update_class_numbers("fortitude") }), on("change:class1_reflex change:class2_reflex change:class3_reflex", e => { pfom.update_class_numbers("reflex") }), on("change:class1_will change:class2_will change:class3_will", e => { pfom.update_class_numbers("will") }), on("change:class1_speed change:class2_speed change:class3_speed", e => { pfom.update_class_numbers("speed") }), on("change:class1_skillranks_base change:class2_skillranks_base change:class3_skillranks_base", e => { pfom.update_skillranks_total() }), on("change:class1_favored change:class2_favored change:class3_favored", e => { setAttrs({ class_favored: e.triggerName.charAt(5) }, { silent: !1 }) }), on("change:class1_skillranks_misc change:class2_skillranks_misc change:class3_skillranks_misc", () => { pfom.update_skillranks_total() }), on("change:initiative_misc change:initiative_bonus", () => { pfom.update_initiative() }), on("change:ac_ability_maximum change:encumbrance_ability_maximum change:ac_condition_nobonus change:ac_secab_monk", e => { pfom.update_ac_ability(e.sourceAttribute) }), on("change:ac_ability_primary change:ac_ability_secondary", e => { pfom.update_ac_ability(e.newValue) }), on("change:ac_bonus change:ac_misc change:ac_armor change:ac_shield change:ac_ability_mod change:ac_size change:ac_flatfooted_items change:ac_touch_items change:ac_natural_items change:ac_deflection_items change:ac_dodge_items change:ac_armor_bonus change:ac_shield_bonus change:ac_natural_bonus change:ac_deflection_bonus change:ac_dodge_bonus change:ac_noflatflooted change:ac_touchshield change:ac_condition", () => { pfom.update_ac() }), on("remove:repeating_acitems change:repeating_acitems:equipped change:repeating_acitems:ac_bonus change:repeating_acitems:flatfooted_bonus change:repeating_acitems:touch_bonus change:repeating_acitems:natural_bonus change:repeating_acitems:deflection_bonus change:repeating_acitems:dodge_bonus change:repeating_acitems:type change:repeating_acitems:check_penalty change:repeating_acitems:max_dex_bonus change:repeating_acitems:spell_failure change:repeating_acitems:speed20 change:repeating_acitems:speed30 change:repeating_acitems:run_factor", () => { pfom.update_ac_items() }), on("change:fortitude_base change:fortitude_ability change:fortitude_misc change:fortitude_bonus", () => { pfom.update_save("fortitude") }), on("change:reflex_base change:reflex_ability change:reflex_misc change:reflex_bonus", () => { pfom.update_save("reflex") }), on("change:will_base change:will_ability change:will_misc change:will_bonus", () => { pfom.update_save("will") }), on("change:bab", e => { pfom.update_babs_all() }), on("change:cmb_ability change:cmb_misc change:cmb_bonus", () => { pfom.update_babs("cmb") }), on("change:melee_ability change:melee_misc change:melee_bonus", () => { pfom.update_babs("melee") }), on("change:ranged_ability change:ranged_misc change:ranged_bonus", () => { pfom.update_babs("ranged") }), on("change:cmd_misc change:cmd_bonus change:cmd_condition", () => { pfom.update_cmd() }), on("change:critconfirm_bonus", () => { pfom.update_attacks("all"), pfom.update_all_spells("all") }), on("change:sr_base change:sr_bonus", () => { pfom.update_sr() }), on("change:repeating_gear:weight change:repeating_gear:quantity", e => { pfom.update_gear_weight(e.sourceAttribute.substring(15, 35)) }), on("change:repeating_gear:weight_total remove:repeating_gear change:encumbrance_coins_weight change:encumbrance_coins_flag", () => { pfom.update_gear_weight_total() }), on("change:money_cp change:money_sp change:money_gp change:money_pp", () => { pfom.update_coins_weight() }), on("change:encumbrance_load_bonus change:encumbrance_load_multiplier change:encumbrance_gear_weight", () => { pfom.update_encumbrance() }), on("change:repeating_abilities:perday_qty", e => { pfom.update_traits(e.sourceAttribute.substring(20, 40)) }), on("change:speed_race change:speed_class", () => { pfom.update_ac_items() }), on("change:speed_notmodified change:speed_encumbrance change:speed_armor change:armor_run_factor change:encumbrance_run_factor change:speed_base change:speed_bonus change:speed_run_factor change:speed_condition change:speed_condition_multiplier change:speed_condition_nospeed change:speed_condition_norun change:speed_climb_misc  change:speed_climb_bonus change:speed_swim_misc change:speed_swim_bonus", () => { pfom.update_speed() }), on("change:repeating_attacks:atkname change:repeating_attacks:atkflag change:repeating_attacks:atktype change:repeating_attacks:atktype2 change:repeating_attacks:atkmod change:repeating_attacks:atkcritrange  change:repeating_attacks:atkrange change:repeating_attacks:dmgflag change:repeating_attacks:dmgbase change:repeating_attacks:dmgattr change:repeating_attacks:dmgmod change:repeating_attacks:dmgcritmulti change:repeating_attacks:dmgtype change:repeating_attacks:dmgbonusdice change:repeating_attacks:dmg2flag change:repeating_attacks:dmg2name change:repeating_attacks:dmg2base change:repeating_attacks:dmg2attr change:repeating_attacks:dmg2mod change:repeating_attacks:dmg2critmulti change:repeating_attacks:dmg2type change:repeating_attacks:dmg2bonusdice change:repeating_attacks:descflag change:repeating_attacks:atkdesc change:repeating_attacks:notes change:repeating_attacks:atkextra1flag change:repeating_attacks:atkextra1name change:repeating_attacks:atkextra1critrange change:repeating_attacks:atkextra1type change:repeating_attacks:atkextra1type2 change:repeating_attacks:atkextra1mod change:repeating_attacks:atkextra1dmgbase change:repeating_attacks:atkextra1dmgattr change:repeating_attacks:atkextra1dmgmod change:repeating_attacks:atkextra1dmgtype change:repeating_attacks:atkextra1dmgcritmulti change:repeating_attacks:atkextra2flag change:repeating_attacks:atkextra2name change:repeating_attacks:atkextra2critrange change:repeating_attacks:atkextra2type change:repeating_attacks:atkextra2type2 change:repeating_attacks:atkextra2mod change:repeating_attacks:atkextra2dmgbase change:repeating_attacks:atkextra2dmgattr change:repeating_attacks:atkextra2dmgmod change:repeating_attacks:atkextra2dmgtype change:repeating_attacks:atkextra2dmgcritmulti change:repeating_attacks:atkextra3flag change:repeating_attacks:atkextra3name change:repeating_attacks:atkextra3critrange change:repeating_attacks:atkextra3type change:repeating_attacks:atkextra3type2 change:repeating_attacks:atkextra3mod change:repeating_attacks:atkextra3dmgbase change:repeating_attacks:atkextra3dmgattr change:repeating_attacks:atkextra3dmgmod change:repeating_attacks:atkextra3dmgtype change:repeating_attacks:atkextra3dmgcritmulti", e => { pfom.update_attacks(e.sourceAttribute.substring(18, 38)) }), on("change:rollnotes_attack change:attack_bonus change:damage_bonus change:melee_damage_bonus change:ranged_damage_bonus", () => { pfom.update_damage_bonus_flag() }), on("change:armor_check_penalty change:encumbrance_check_penalty", () => { pfom.update_all_skills() }), on("change:acrobatics_classkill change:acrobatics_ability change:acrobatics_ranks change:acrobatics_misc change:acrobatics_bonus change:acrobatics_armor_penalty", e => { pfom.update_skill("acrobatics", e.sourceAttribute) }), on("change:appraise_classkill change:appraise_ability change:appraise_ranks change:appraise_misc change:appraise_bonus change:appraise_armor_penalty", e => { pfom.update_skill("appraise", e.sourceAttribute) }), on("change:bluff_classkill change:bluff_ability change:bluff_ranks change:bluff_misc change:bluff_bonus change:bluff_armor_penalty", e => { pfom.update_skill("bluff", e.sourceAttribute) }), on("change:climb_classkill change:climb_ability change:climb_ranks change:climb_misc change:climb_bonus change:climb_armor_penalty", e => { pfom.update_skill("climb", e.sourceAttribute) }), on("change:craft_classkill change:craft_ability change:craft_ranks change:craft_misc change:craft_bonus change:craft_armor_penalty", e => { pfom.update_skill("craft", e.sourceAttribute) }), on("change:repeating_skillcraft:classkill change:repeating_skillcraft:name change:repeating_skillcraft:ability change:repeating_skillcraft:ranks change:repeating_skillcraft:misc change:repeating_skillcraft:bonus change:repeating_skillcraft:armor_penalty", e => { pfom.update_skill(e.sourceAttribute.substring(0, 41), e.sourceAttribute) }), on("change:diplomacy_classkill change:diplomacy_ability change:diplomacy_ranks change:diplomacy_misc change:diplomacy_bonus change:diplomacy_armor_penalty", e => { pfom.update_skill("diplomacy", e.sourceAttribute) }), on("change:disable_device_classkill change:disable_device_ability change:disable_device_ranks change:disable_device_misc change:disable_device_bonus change:disable_device_armor_penalty", e => { pfom.update_skill("disable_device", e.sourceAttribute) }), on("change:disguise_classkill change:disguise_ability change:disguise_ranks change:disguise_misc change:disguise_bonus change:disguise_armor_penalty", e => { pfom.update_skill("disguise", e.sourceAttribute) }), on("change:escape_artist_classkill change:escape_artist_ability change:escape_artist_ranks change:escape_artist_misc change:escape_artist_bonus change:escape_artist_armor_penalty", e => { pfom.update_skill("escape_artist", e.sourceAttribute) }), on("change:fly_classkill change:fly_ability change:fly_ranks change:fly_misc change:fly_bonus change:fly_armor_penalty", e => { pfom.update_skill("fly", e.sourceAttribute) }), on("change:handle_animal_classkill change:handle_animal_ability change:handle_animal_ranks change:handle_animal_misc change:handle_animal_bonus change:handle_animal_armor_penalty", e => { pfom.update_skill("handle_animal", e.sourceAttribute) }), on("change:heal_classkill change:heal_ability change:heal_ranks change:heal_misc change:heal_bonus change:heal_armor_penalty", e => { pfom.update_skill("heal", e.sourceAttribute) }), on("change:intimidate_classkill change:intimidate_ability change:intimidate_ranks change:intimidate_misc change:intimidate_bonus change:intimidate_armor_penalty", e => { pfom.update_skill("intimidate", e.sourceAttribute) }), on("change:knowledge_arcana_classkill change:knowledge_arcana_ability change:knowledge_arcana_ranks change:knowledge_arcana_misc change:knowledge_arcana_bonus change:knowledge_arcana_armor_penalty", e => { pfom.update_skill("knowledge_arcana", e.sourceAttribute) }), on("change:knowledge_dungeoneering_classkill change:knowledge_dungeoneering_ability change:knowledge_dungeoneering_ranks change:knowledge_dungeoneering_misc change:knowledge_dungeoneering_bonus change:knowledge_dungeoneering_armor_penalty", e => { pfom.update_skill("knowledge_dungeoneering", e.sourceAttribute) }), on("change:knowledge_engineering_classkill change:knowledge_engineering_ability change:knowledge_engineering_ranks change:knowledge_engineering_misc change:knowledge_engineering_bonus change:knowledge_engineering_armor_penalty", e => { pfom.update_skill("knowledge_engineering", e.sourceAttribute) }), on("change:knowledge_geography_classkill change:knowledge_geography_ability change:knowledge_geography_ranks change:knowledge_geography_misc change:knowledge_geography_bonus change:knowledge_geography_armor_penalty", e => { pfom.update_skill("knowledge_geography", e.sourceAttribute) }), on("change:knowledge_history_classkill change:knowledge_history_ability change:knowledge_history_ranks change:knowledge_history_misc change:knowledge_history_bonus change:knowledge_history_armor_penalty", e => { pfom.update_skill("knowledge_history", e.sourceAttribute) }), on("change:knowledge_local_classkill change:knowledge_local_ability change:knowledge_local_ranks change:knowledge_local_misc change:knowledge_local_bonus change:knowledge_local_armor_penalty", e => { pfom.update_skill("knowledge_local", e.sourceAttribute) }), on("change:knowledge_nature_classkill change:knowledge_nature_ability change:knowledge_nature_ranks change:knowledge_nature_misc change:knowledge_nature_bonus change:knowledge_nature_armor_penalty", e => { pfom.update_skill("knowledge_nature", e.sourceAttribute) }), on("change:knowledge_nobility_classkill change:knowledge_nobility_ability change:knowledge_nobility_ranks change:knowledge_nobility_misc change:knowledge_nobility_bonus change:knowledge_nobility_armor_penalty", e => { pfom.update_skill("knowledge_nobility", e.sourceAttribute) }), on("change:knowledge_planes_classkill change:knowledge_planes_ability change:knowledge_planes_ranks change:knowledge_planes_misc change:knowledge_planes_bonus change:knowledge_planes_armor_penalty", e => { pfom.update_skill("knowledge_planes", e.sourceAttribute) }), on("change:knowledge_religion_classkill change:knowledge_religion_ability change:knowledge_religion_ranks change:knowledge_religion_misc change:knowledge_religion_bonus change:knowledge_religion_armor_penalty", e => { pfom.update_skill("knowledge_religion", e.sourceAttribute) }), on("change:repeating_skillknowledge:classkill change:repeating_skillknowledge:name change:repeating_skillknowledge:ability change:repeating_skillknowledge:ranks change:repeating_skillknowledge:misc change:repeating_skillknowledge:bonus change:repeating_skillknowledge:armor_penalty", e => { pfom.update_skill(e.sourceAttribute.substring(0, 45), e.sourceAttribute) }), on("change:linguistics_classkill change:linguistics_ability change:linguistics_ranks change:linguistics_misc change:linguistics_bonus change:linguistics_armor_penalty", e => { pfom.update_skill("linguistics", e.sourceAttribute) }), on("change:perception_classkill change:perception_ability change:perception_ranks change:perception_misc change:perception_bonus change:perception_armor_penalty", e => { pfom.update_skill("perception", e.sourceAttribute) }), on("change:perform_classkill change:perform_ability change:perform_ranks change:perform_misc change:perform_bonus change:perform_armor_penalty", e => { pfom.update_skill("perform", e.sourceAttribute) }), on("change:repeating_skillperform:classkill change:repeating_skillperform:name change:repeating_skillperform:ability change:repeating_skillperform:ranks change:repeating_skillperform:misc change:repeating_skillperform:bonus change:repeating_skillperform:armor_penalty", e => {
        var skillid = e.sourceAttribute.substring(0, 43);
        pfom.update_skill(skillid, e.sourceAttribute)
    }), on("change:profession_classkill change:profession_ability change:profession_ranks change:profession_misc change:profession_bonus change:profession_armor_penalty", e => { pfom.update_skill("profession", e.sourceAttribute) }), on("change:repeating_skillprofession:classkill change:repeating_skillprofession:name change:repeating_skillprofession:ability change:repeating_skillprofession:ranks change:repeating_skillprofession:misc change:repeating_skillprofession:bonus change:repeating_skillprofession:armor_penalty", e => { pfom.update_skill(e.sourceAttribute.substring(0, 46), e.sourceAttribute) }), on("change:ride_classkill change:ride_ability change:ride_ranks change:ride_misc change:ride_bonus change:ride_armor_penalty", e => { pfom.update_skill("ride", e.sourceAttribute) }), on("change:sense_motive_classkill change:sense_motive_ability change:sense_motive_ranks change:sense_motive_misc change:sense_motive_bonus change:sense_motive_armor_penalty", e => { pfom.update_skill("sense_motive", e.sourceAttribute) }), on("change:sleight_of_hand_classkill change:sleight_of_hand_ability change:sleight_of_hand_ranks change:sleight_of_hand_misc change:sleight_of_hand_bonus change:sleight_of_hand_armor_penalty", e => { pfom.update_skill("sleight_of_hand", e.sourceAttribute) }), on("change:spellcraft_classkill change:spellcraft_ability change:spellcraft_ranks change:spellcraft_misc change:spellcraft_bonus change:spellcraft_armor_penalty", e => { pfom.update_skill("spellcraft", e.sourceAttribute) }), on("change:stealth_classkill change:stealth_ability change:stealth_ranks change:stealth_misc change:stealth_bonus change:stealth_armor_penalty", e => { pfom.update_skill("stealth", e.sourceAttribute) }), on("change:survival_classkill change:survival_ability change:survival_ranks change:survival_misc change:survival_bonus change:survival_armor_penalty", e => { pfom.update_skill("survival", e.sourceAttribute) }), on("change:swim_classkill change:swim_ability change:swim_ranks change:swim_misc change:swim_bonus change:swim_armor_penalty", e => { pfom.update_skill("swim", e.sourceAttribute) }), on("change:use_magic_device_classkill change:use_magic_device_ability change:use_magic_device_ranks change:use_magic_device_misc change:use_magic_device_bonus change:use_magic_device_armor_penalty", e => { pfom.update_skill("use_magic_device", e.sourceAttribute) }), on("change:repeating_skillcustom:classkill change:repeating_skillcustom:name change:repeating_skillcustom:ability change:repeating_skillcustom:ranks change:repeating_skillcustom:misc change:repeating_skillcustom:bonus change:repeating_skillcustom:armor_penalty", e => { pfom.update_skill(e.sourceAttribute.substring(0, 42), e.sourceAttribute) }), on("remove:repeating_skillcraft remove:repeating_skillknowledge remove:repeating_skillperform remove:repeating_skillprofession remove:repeating_skillcustom", e => { pfom.update_skills_ranks() }), on("change:armor_spell_failure change:caster1_spell_failure change:caster2_spell_failure", () => { getAttrs(["npc", "caster1_flag", "caster2_flag"], v => { "1" == v.npc || "1" != v.caster1_flag && "1" != v.caster2_flag || pfom.update_all_spells("all") }) }), on("change:caster1_ability change:caster1_level change:caster1_concentration_misc change:caster1_concentration_bonus change:caster2_ability change:caster2_level change:caster2_concentration_misc change:caster2_concentration_bonus", e => { pfom.update_concentration(e.sourceAttribute) }), on("change:caster1_dc_misc change:caster1_dcbonus_level_0 change:caster1_dcbonus_level_1 change:caster1_dcbonus_level_2 change:caster1_dcbonus_level_3 change:caster1_dcbonus_level_4 change:caster1_dcbonus_level_5 change:caster1_dcbonus_level_6 change:caster1_dcbonus_level_7 change:caster1_dcbonus_level_8 change:caster1_dcbonus_level_9 change:caster2_dc_misc change:caster2_dcbonus_level_0 change:caster2_dcbonus_level_1 change:caster2_dcbonus_level_2 change:caster2_dcbonus_level_3 change:caster2_dcbonus_level_4 change:caster2_dcbonus_level_5 change:caster2_dcbonus_level_6 change:caster2_dcbonus_level_7 change:caster2_dcbonus_level_8 change:caster2_dcbonus_level_9", e => { pfom.update_spells_dc(e.sourceAttribute) }), on("change:caster1_dc_level_0 change:caster1_dc_level_1 change:caster1_dc_level_2 change:caster1_dc_level_3 change:caster1_dc_level_4 change:caster1_dc_level_5 change:caster1_dc_level_6 change:caster1_dc_level_7 change:caster1_dc_level_8 change:caster1_dc_level_9 change:caster2_dc_level_0 change:caster2_dc_level_1 change:caster2_dc_level_2 change:caster2_dc_level_3 change:caster2_dc_level_4 change:caster2_dc_level_5 change:caster2_dc_level_6 change:caster2_dc_level_7 change:caster2_dc_level_8 change:caster2_dc_level_9", e => { pfom.update_spells(e.sourceAttribute.charAt(e.sourceAttribute.length - 1), "all") }), on("change:caster1_spells_known_level_0 change:caster1_spells_known_level_1 change:caster1_spells_known_level_2 change:caster1_spells_known_level_3 change:caster1_spells_known_level_4 change:caster1_spells_known_level_5 change:caster1_spells_known_level_6 change:caster1_spells_known_level_7 change:caster1_spells_known_level_8 change:caster1_spells_known_level_9 change:caster2_spells_known_level_0 change:caster2_spells_known_level_1 change:caster2_spells_known_level_2 change:caster2_spells_known_level_3 change:caster2_spells_known_level_4 change:caster2_spells_known_level_5 change:caster2_spells_known_level_6 change:caster2_spells_known_level_7 change:caster2_spells_known_level_8 change:caster2_spells_known_level_9 change:caster1_spells_total_level_0 change:caster1_spells_total_level_1 change:caster1_spells_total_level_2 change:caster1_spells_total_level_3 change:caster1_spells_total_level_4 change:caster1_spells_total_level_5 change:caster1_spells_total_level_6 change:caster1_spells_total_level_7 change:caster1_spells_total_level_8 change:caster1_spells_total_level_9 change:caster2_spells_total_level_0 change:caster2_spells_total_level_1 change:caster2_spells_total_level_2 change:caster2_spells_total_level_3 change:caster2_spells_total_level_4 change:caster2_spells_total_level_5 change:caster2_spells_total_level_6 change:caster2_spells_total_level_7 change:caster2_spells_total_level_8 change:caster2_spells_total_level_9", e => { pfom.update_spells_flag(e.sourceAttribute.charAt(e.sourceAttribute.length - 1)) }), on("change:caster1_spells_perday_level_0 change:caster1_spells_perday_level_1 change:caster1_spells_perday_level_2 change:caster1_spells_perday_level_3 change:caster1_spells_perday_level_4 change:caster1_spells_perday_level_5 change:caster1_spells_perday_level_6 change:caster1_spells_perday_level_7 change:caster1_spells_perday_level_8 change:caster1_spells_perday_level_9 change:caster1_spells_bonus_level_0 change:caster1_spells_bonus_level_1 change:caster1_spells_bonus_level_2 change:caster1_spells_bonus_level_3 change:caster1_spells_bonus_level_4 change:caster1_spells_bonus_level_5 change:caster1_spells_bonus_level_6 change:caster1_spells_bonus_level_7 change:caster1_spells_bonus_level_8 change:caster1_spells_bonus_level_9", e => { pfom.update_spells_totals(e.sourceAttribute.charAt(e.sourceAttribute.length - 1), 1) }), on("change:caster2_spells_perday_level_0 change:caster2_spells_perday_level_1 change:caster2_spells_perday_level_2 change:caster2_spells_perday_level_3 change:caster2_spells_perday_level_4 change:caster2_spells_perday_level_5 change:caster2_spells_perday_level_6 change:caster2_spells_perday_level_7 change:caster2_spells_perday_level_8 change:caster2_spells_perday_level_9 change:caster2_spells_bonus_level_0 change:caster2_spells_bonus_level_1 change:caster2_spells_bonus_level_2 change:caster2_spells_bonus_level_3 change:caster2_spells_bonus_level_4 change:caster2_spells_bonus_level_5 change:caster2_spells_bonus_level_6 change:caster2_spells_bonus_level_7 change:caster2_spells_bonus_level_8 change:caster2_spells_bonus_level_9", e => { pfom.update_spells_totals(e.sourceAttribute.charAt(e.sourceAttribute.length - 1), 2) }), on("change:repeating_spell-0:spellprepared change:repeating_spell-1:spellprepared change:repeating_spell-2:spellprepared change:repeating_spell-3:spellprepared change:repeating_spell-4:spellprepared change:repeating_spell-5:spellprepared change:repeating_spell-6:spellprepared change:repeating_spell-7:spellprepared change:repeating_spell-8:spellprepared change:repeating_spell-9:spellprepared", e => { pfom.update_spells_prepared(e.sourceAttribute, e.newValue) }), on("remove:repeating_spell-0 remove:repeating_spell-1 remove:repeating_spell-2 remove:repeating_spell-3 remove:repeating_spell-4 remove:repeating_spell-5 remove:repeating_spell-6 remove:repeating_spell-7 remove:repeating_spell-8 remove:repeating_spell-9", e => { pfom.update_spells_prepared(e.sourceAttribute, "") }), on("change:repeating_spell-0:spellcaster change:repeating_spell-0:spellname change:repeating_spell-0:spellschool change:repeating_spell-0:spellclasslevel change:repeating_spell-0:spellcastingtime change:repeating_spell-0:spellcomponent change:repeating_spell-0:spellrange change:repeating_spell-0:spellarea change:repeating_spell-0:spelltargets change:repeating_spell-0:spelleffect change:repeating_spell-0:spellduration change:repeating_spell-0:spellsaveflag change:repeating_spell-0:spellsave change:repeating_spell-0:spelldc_mod change:repeating_spell-0:spellresistanceflag change:repeating_spell-0:spellresistance change:repeating_spell-0:spellatkflag change:repeating_spell-0:spellatktype change:repeating_spell-0:spellatkmod change:repeating_spell-0:spellatkcritrange change:repeating_spell-0:spelldmgcritmulti change:repeating_spell-0:spelldmgflag change:repeating_spell-0:spelldmg change:repeating_spell-0:spelldmgtype change:repeating_spell-0:spelldmg2flag change:repeating_spell-0:spelldmg2name change:repeating_spell-0:spelldmg2 change:repeating_spell-0:spelldmg2type change:repeating_spell-0:spelldescflag change:repeating_spell-0:spelldesc change:repeating_spell-0:notes", e => { pfom.update_spells(0, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-1:spellcaster change:repeating_spell-1:spellname change:repeating_spell-1:spellschool change:repeating_spell-1:spellclasslevel change:repeating_spell-1:spellcastingtime change:repeating_spell-1:spellcomponent change:repeating_spell-1:spellrange change:repeating_spell-1:spellarea change:repeating_spell-1:spelltargets change:repeating_spell-1:spelleffect change:repeating_spell-1:spellduration change:repeating_spell-1:spellsaveflag change:repeating_spell-1:spellsave change:repeating_spell-1:spelldc_mod change:repeating_spell-1:spellresistanceflag change:repeating_spell-1:spellresistance change:repeating_spell-1:spellatkflag change:repeating_spell-1:spellatktype change:repeating_spell-1:spellatkmod change:repeating_spell-1:spellatkcritrange change:repeating_spell-1:spelldmgcritmulti change:repeating_spell-1:spelldmgflag change:repeating_spell-1:spelldmg change:repeating_spell-1:spelldmgtype change:repeating_spell-1:spelldmg2flag change:repeating_spell-1:spelldmg2name change:repeating_spell-1:spelldmg2 change:repeating_spell-1:spelldmg2type change:repeating_spell-1:spelldescflag change:repeating_spell-1:spelldesc change:repeating_spell-1:notes", e => { pfom.update_spells(1, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-2:spellcaster change:repeating_spell-2:spellname change:repeating_spell-2:spellschool change:repeating_spell-2:spellclasslevel change:repeating_spell-2:spellcastingtime change:repeating_spell-2:spellcomponent change:repeating_spell-2:spellrange change:repeating_spell-2:spellarea change:repeating_spell-2:spelltargets change:repeating_spell-2:spelleffect change:repeating_spell-2:spellduration change:repeating_spell-2:spellsaveflag change:repeating_spell-2:spellsave change:repeating_spell-2:spelldc_mod change:repeating_spell-2:spellresistanceflag change:repeating_spell-2:spellresistance change:repeating_spell-2:spellatkflag change:repeating_spell-2:spellatktype change:repeating_spell-2:spellatkmod change:repeating_spell-2:spellatkcritrange change:repeating_spell-2:spelldmgcritmulti change:repeating_spell-2:spelldmgflag change:repeating_spell-2:spelldmg change:repeating_spell-2:spelldmgtype change:repeating_spell-2:spelldmg2flag change:repeating_spell-2:spelldmg2name change:repeating_spell-2:spelldmg2 change:repeating_spell-2:spelldmg2type change:repeating_spell-2:spelldescflag change:repeating_spell-2:spelldesc change:repeating_spell-2:notes", e => { pfom.update_spells(2, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-3:spellcaster change:repeating_spell-3:spellname change:repeating_spell-3:spellschool change:repeating_spell-3:spellclasslevel change:repeating_spell-3:spellcastingtime change:repeating_spell-3:spellcomponent change:repeating_spell-3:spellrange change:repeating_spell-3:spellarea change:repeating_spell-3:spelltargets change:repeating_spell-3:spelleffect change:repeating_spell-3:spellduration change:repeating_spell-3:spellsaveflag change:repeating_spell-3:spellsave change:repeating_spell-3:spelldc_mod change:repeating_spell-3:spellresistanceflag change:repeating_spell-3:spellresistance change:repeating_spell-3:spellatkflag change:repeating_spell-3:spellatktype change:repeating_spell-3:spellatkmod change:repeating_spell-3:spellatkcritrange change:repeating_spell-3:spelldmgcritmulti change:repeating_spell-3:spelldmgflag change:repeating_spell-3:spelldmg change:repeating_spell-3:spelldmgtype change:repeating_spell-3:spelldmg2flag change:repeating_spell-3:spelldmg2name change:repeating_spell-3:spelldmg2 change:repeating_spell-3:spelldmg2type change:repeating_spell-3:spelldescflag change:repeating_spell-3:spelldesc change:repeating_spell-3:notes", e => { pfom.update_spells(3, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-4:spellcaster change:repeating_spell-4:spellname change:repeating_spell-4:spellschool change:repeating_spell-4:spellclasslevel change:repeating_spell-4:spellcastingtime change:repeating_spell-4:spellcomponent change:repeating_spell-4:spellrange change:repeating_spell-4:spellarea change:repeating_spell-4:spelltargets change:repeating_spell-4:spelleffect change:repeating_spell-4:spellduration change:repeating_spell-4:spellsaveflag change:repeating_spell-4:spellsave change:repeating_spell-4:spelldc_mod change:repeating_spell-4:spellresistanceflag change:repeating_spell-4:spellresistance change:repeating_spell-4:spellatkflag change:repeating_spell-4:spellatktype change:repeating_spell-4:spellatkmod change:repeating_spell-4:spellatkcritrange change:repeating_spell-4:spelldmgcritmulti change:repeating_spell-4:spelldmgflag change:repeating_spell-4:spelldmg change:repeating_spell-4:spelldmgtype change:repeating_spell-4:spelldmg2flag change:repeating_spell-4:spelldmg2name change:repeating_spell-4:spelldmg2 change:repeating_spell-4:spelldmg2type change:repeating_spell-4:spelldescflag change:repeating_spell-4:spelldesc change:repeating_spell-4:notes", e => { pfom.update_spells(4, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-5:spellcaster change:repeating_spell-5:spellname change:repeating_spell-5:spellschool change:repeating_spell-5:spellclasslevel change:repeating_spell-5:spellcastingtime change:repeating_spell-5:spellcomponent change:repeating_spell-5:spellrange change:repeating_spell-5:spellarea change:repeating_spell-5:spelltargets change:repeating_spell-5:spelleffect change:repeating_spell-5:spellduration change:repeating_spell-5:spellsaveflag change:repeating_spell-5:spellsave change:repeating_spell-5:spelldc_mod change:repeating_spell-5:spellresistanceflag change:repeating_spell-5:spellresistance change:repeating_spell-5:spellatkflag change:repeating_spell-5:spellatktype change:repeating_spell-5:spellatkmod change:repeating_spell-5:spellatkcritrange change:repeating_spell-5:spelldmgcritmulti change:repeating_spell-5:spelldmgflag change:repeating_spell-5:spelldmg change:repeating_spell-5:spelldmgtype change:repeating_spell-5:spelldmg2flag change:repeating_spell-5:spelldmg2name change:repeating_spell-5:spelldmg2 change:repeating_spell-5:spelldmg2type change:repeating_spell-5:spelldescflag change:repeating_spell-5:spelldesc change:repeating_spell-5:notes", e => { pfom.update_spells(5, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-6:spellcaster change:repeating_spell-6:spellname change:repeating_spell-6:spellschool change:repeating_spell-6:spellclasslevel change:repeating_spell-6:spellcastingtime change:repeating_spell-6:spellcomponent change:repeating_spell-6:spellrange change:repeating_spell-6:spellarea change:repeating_spell-6:spelltargets change:repeating_spell-6:spelleffect change:repeating_spell-6:spellduration change:repeating_spell-6:spellsaveflag change:repeating_spell-6:spellsave change:repeating_spell-6:spelldc_mod change:repeating_spell-6:spellresistanceflag change:repeating_spell-6:spellresistance change:repeating_spell-6:spellatkflag change:repeating_spell-6:spellatktype change:repeating_spell-6:spellatkmod change:repeating_spell-6:spellatkcritrange change:repeating_spell-6:spelldmgcritmulti change:repeating_spell-6:spelldmgflag change:repeating_spell-6:spelldmg change:repeating_spell-6:spelldmgtype change:repeating_spell-6:spelldmg2flag change:repeating_spell-6:spelldmg2name change:repeating_spell-6:spelldmg2 change:repeating_spell-6:spelldmg2type change:repeating_spell-6:spelldescflag change:repeating_spell-6:spelldesc change:repeating_spell-6:notes", e => { pfom.update_spells(6, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-7:spellcaster change:repeating_spell-7:spellname change:repeating_spell-7:spellschool change:repeating_spell-7:spellclasslevel change:repeating_spell-7:spellcastingtime change:repeating_spell-7:spellcomponent change:repeating_spell-7:spellrange change:repeating_spell-7:spellarea change:repeating_spell-7:spelltargets change:repeating_spell-7:spelleffect change:repeating_spell-7:spellduration change:repeating_spell-7:spellsaveflag change:repeating_spell-7:spellsave change:repeating_spell-7:spelldc_mod change:repeating_spell-7:spellresistanceflag change:repeating_spell-7:spellresistance change:repeating_spell-7:spellatkflag change:repeating_spell-7:spellatktype change:repeating_spell-7:spellatkmod change:repeating_spell-7:spellatkcritrange change:repeating_spell-7:spelldmgcritmulti change:repeating_spell-7:spelldmgflag change:repeating_spell-7:spelldmg change:repeating_spell-7:spelldmgtype change:repeating_spell-7:spelldmg2flag change:repeating_spell-7:spelldmg2name change:repeating_spell-7:spelldmg2 change:repeating_spell-7:spelldmg2type change:repeating_spell-7:spelldescflag change:repeating_spell-7:spelldesc change:repeating_spell-7:notes", e => { pfom.update_spells(7, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-8:spellcaster change:repeating_spell-8:spellname change:repeating_spell-8:spellschool change:repeating_spell-8:spellclasslevel change:repeating_spell-8:spellcastingtime change:repeating_spell-8:spellcomponent change:repeating_spell-8:spellrange change:repeating_spell-8:spellarea change:repeating_spell-8:spelltargets change:repeating_spell-8:spelleffect change:repeating_spell-8:spellduration change:repeating_spell-8:spellsaveflag change:repeating_spell-8:spellsave change:repeating_spell-8:spelldc_mod change:repeating_spell-8:spellresistanceflag change:repeating_spell-8:spellresistance change:repeating_spell-8:spellatkflag change:repeating_spell-8:spellatktype change:repeating_spell-8:spellatkmod change:repeating_spell-8:spellatkcritrange change:repeating_spell-8:spelldmgcritmulti change:repeating_spell-8:spelldmgflag change:repeating_spell-8:spelldmg change:repeating_spell-8:spelldmgtype change:repeating_spell-8:spelldmg2flag change:repeating_spell-8:spelldmg2name change:repeating_spell-8:spelldmg2 change:repeating_spell-8:spelldmg2type change:repeating_spell-8:spelldescflag change:repeating_spell-8:spelldesc change:repeating_spell-8:notes", e => { pfom.update_spells(8, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-9:spellcaster change:repeating_spell-9:spellname change:repeating_spell-9:spellschool change:repeating_spell-9:spellclasslevel change:repeating_spell-9:spellcastingtime change:repeating_spell-9:spellcomponent change:repeating_spell-9:spellrange change:repeating_spell-9:spellarea change:repeating_spell-9:spelltargets change:repeating_spell-9:spelleffect change:repeating_spell-9:spellduration change:repeating_spell-9:spellsaveflag change:repeating_spell-9:spellsave change:repeating_spell-9:spelldc_mod change:repeating_spell-9:spellresistanceflag change:repeating_spell-9:spellresistance change:repeating_spell-9:spellatkflag change:repeating_spell-9:spellatktype change:repeating_spell-9:spellatkmod change:repeating_spell-9:spellatkcritrange change:repeating_spell-9:spelldmgcritmulti change:repeating_spell-9:spelldmgflag change:repeating_spell-9:spelldmg change:repeating_spell-9:spelldmgtype change:repeating_spell-9:spelldmg2flag change:repeating_spell-9:spelldmg2name change:repeating_spell-9:spelldmg2 change:repeating_spell-9:spelldmg2type change:repeating_spell-9:spelldescflag change:repeating_spell-9:spelldesc change:repeating_spell-9:notes", e => { pfom.update_spells(9, e.sourceAttribute.substring(18, 38)) }), on("change:repeating_spell-like:spellname change:repeating_spell-like:spelltype change:repeating_spell-like:spellschool change:repeating_spell-like:spellclasslevel change:repeating_spell-like:spellcastingtime change:repeating_spell-like:spellrange change:repeating_spell-like:spellarea change:repeating_spell-like:spelltargets change:repeating_spell-like:spelleffect change:repeating_spell-like:spellduration change:repeating_spell-like:spellsaveflag change:repeating_spell-like:spellsave change:repeating_spell-like:spelldc_mod change:repeating_spell-like:spellresistanceflag change:repeating_spell-like:spellresistance change:repeating_spell-like:spellatkflag change:repeating_spell-like:spellatktype change:repeating_spell-like:spellatkmod change:repeating_spell-like:spellatkcritrange change:repeating_spell-like:spelldmgcritmulti change:repeating_spell-like:spelldmgflag change:repeating_spell-like:spelldmg change:repeating_spell-like:spelldmgtype change:repeating_spell-like:spelldmg2flag change:repeating_spell-like:spelldmg2name change:repeating_spell-like:spelldmg2 change:repeating_spell-like:spelldmg2type change:repeating_spell-like:spelldescflag change:repeating_spell-like:spelldesc change:repeating_spell-like:notes change:repeating_spell-like:timesperday change:repeating_spell-like:perday_max change:repeating_spell-like:perday_qty", e => { pfom.update_spells("like", e.sourceAttribute.substring(21, 41)) }), on("change:condition_bleed change:condition_blinded change:condition_confused change:condition_cowering change:condition_dazed change:condition_dazzled change:condition_deafened change:condition_disabled change:condition_dying change:condition_energy_drained change:condition_entangled change:condition_exhausted change:condition_fascinated change:condition_fatigued change:condition_flat-footed change:condition_frightened change:condition_grappled change:condition_helpless change:condition_incorporeal change:condition_invisible change:condition_nauseated change:condition_panicked change:condition_paralyzed change:condition_petrified change:condition_pinned change:condition_prone change:condition_shaken change:condition_sickened change:condition_stable change:condition_staggered change:condition_stunned change:condition_unconscious ", () => { pfom.le_big_stuff("all") }), on("clicked:reset_conditions", () => { pfom.le_big_stuff("all", { reset_conditions: !0 }) }), on("change:conditions_display", e => { e.newValue && " " == e.newValue && setAttrs({ conditions_display: "" }, { silent: !0 }) }), on("change:repeating_buff:name change:repeating_buff:toggle change:repeating_buff:mods", e => { pfom.le_big_stuff("all") }), on("clicked:reset_buffs", () => { pfom.le_big_stuff("all", { reset_buffs: !0 }) }), on("change:buffs_display", e => { e.newValue && " " == e.newValue && setAttrs({ buffs_display: "" }, { silent: !0 }) }), on("clicked:reset_buffs_conditions", () => { pfom.le_big_stuff("all", { reset_buffs: !0, reset_conditions: !0 }) }), on("change:whispertype change:rollshowchar", () => { pfom.update_attacks("all"), pfom.update_all_spells("all") }), on("clicked:npc_confirm", () => { pfom.reset_to_xpc(1) }), on("clicked:npc_cancel", () => { setAttrs({ npc_confirm_flag: 0 }) }), on("clicked:npc_to_pc", () => { pfom.reset_to_xpc(0) }), on("clicked:pc_to_npc", () => { setAttrs({ npc_confirm_flag: 1 }) }), on("change:repeating_npcatk-melee:atkname change:repeating_npcatk-melee:atkmod change:repeating_npcatk-melee:multipleatk_flag change:repeating_npcatk-melee:atkmod2 change:repeating_npcatk-melee:atkmod3 change:repeating_npcatk-melee:atkmod4 change:repeating_npcatk-melee:atkmod5 change:repeating_npcatk-melee:atkmod6 change:repeating_npcatk-melee:atkmod7 change:repeating_npcatk-melee:atkmod8 change:repeating_npcatk-melee:atkmod9 change:repeating_npcatk-melee:atkcritrange change:repeating_npcatk-melee:dmgflag change:repeating_npcatk-melee:dmgbase change:repeating_npcatk-melee:dmgtype change:repeating_npcatk-melee:dmgcritmulti change:repeating_npcatk-melee:dmg2flag change:repeating_npcatk-melee:dmg2base change:repeating_npcatk-melee:dmg2type change:repeating_npcatk-melee:dmg2critmulti", e => { pfom.update_npc_attack("melee", e.sourceAttribute.substring(23, 43)) }), on("change:repeating_npcatk-ranged:atkname change:repeating_npcatk-ranged:atkmod change:repeating_npcatk-ranged:multipleatk_flag change:repeating_npcatk-ranged:atkmod2 change:repeating_npcatk-ranged:atkmod3 change:repeating_npcatk-ranged:atkmod4 change:repeating_npcatk-ranged:atkmod5 change:repeating_npcatk-ranged:atkmod6 change:repeating_npcatk-ranged:atkmod7 change:repeating_npcatk-ranged:atkmod8 change:repeating_npcatk-ranged:atkmod9 change:repeating_npcatk-ranged:atkcritrange change:repeating_npcatk-ranged:atkrange change:repeating_npcatk-ranged:dmgflag change:repeating_npcatk-ranged:dmgbase change:repeating_npcatk-ranged:dmgtype change:repeating_npcatk-ranged:dmgcritmulti change:repeating_npcatk-ranged:dmg2flag change:repeating_npcatk-ranged:dmg2base change:repeating_npcatk-ranged:dmg2type change:repeating_npcatk-ranged:dmg2critmulti", e => { pfom.update_npc_attack("ranged", e.sourceAttribute.substring(24, 44)) }), on("change:acrobatics change:acrobatics_notes change:appraise change:appraise_notes change:bluff change:bluff_notes change:climb change:climb_notes change:craft change:craft_notes change:diplomacy change:diplomacy_notes change:disable_device change:disable_device_notes change:disguise change:disguise_notes change:escape_artist change:escape_artist_notes change:fly change:fly_notes change:handle_animal change:handle_animal_notes change:heal change:heal_notes change:intimidate change:intimidate_notes change:knowledge_arcana change:knowledge_arcana_notes change:knowledge_dungeoneering change:knowledge_dungeoneering_notes change:knowledge_engineering change:knowledge_engineering_notes change:knowledge_geography change:knowledge_geography_notes change:knowledge_history change:knowledge_history_notes change:knowledge_local change:knowledge_local_notes change:knowledge_nature change:knowledge_nature_notes change:knowledge_nobility change:knowledge_nobility_notes change:knowledge_planes change:knowledge_planes_notes change:knowledge_religion change:knowledge_religion_notes change:linguistics change:linguistics_notes change:perception change:perception_notes change:perform change:perform_notes change:profession change:profession_notes change:ride change:ride_notes change:sense_motive change:sense_motive_notes change:sleight_of_hand change:sleight_of_hand_notes change:spellcraft change:spellcraft_notes change:stealth change:stealth_notes change:survival change:survival_notes change:swim change:swim_notes change:use_magic_device change:use_magic_device_notes", e => {
        var skill = "";
        skill = "_notes" == e.sourceAttribute.slice(-6) ? e.sourceAttribute.substring(0, e.sourceAttribute.indexOf("_notes")) : e.sourceAttribute, getAttrs(["npc", skill, skill + "_notes"], v => { "1" == v.npc && setAttrs(pfom.calc_npc_skill_display(skill, v[skill], v[skill + "_notes"]), { silent: !0 }) })
    }), on("change:npcdrop_data", e => {
        if ((!e.triggerType || e.triggerType && "compendium" == e.triggerType) && e && e.newValue) {
            var cdata;
            try { cdata = JSON.parse(e.newValue) || {} } catch (error) { cdata = {} } _.isEmpty(cdata) || cdata.Category && "bestiary" == cdata.Category.toLowerCase() && setAttrs({ npc: 1, "options-flag-npc": 0, "build-flag-npc": 1 }, { silent: !0 }, () => { getAttrs(["npcdrop_name", "npcdrop_uniq"], v => { pfom.update_npc_drop(cdata, v, () => { pfom.update_default_token() }) }) })
        }
    }), on("change:npcsplike_data", e => {
        if (e.newValue) {
            let cdata;
            try { cdata = JSON.parse(e.newValue) || {} } catch (error) { cdata = {} } if (!_.isEmpty(cdata)) {
                "spells" == cdata.Category.toLowerCase() && getAttrs(["npcsplike_name", "npcsplike_uniq", "npcsplike_content"], v => {
                    let objs = [], obj = {}, page = {}, pages = [], update = {}, tmpupd = {};
                    obj.Name = v.npcsplike_name, obj.Frequency = "At Will", obj.Spell = v.npcsplike_name, obj.spellcaster = "2", objs.push(obj), page.name = v.npcsplike_name, page.id = v.npcsplike_uniq, page.content = v.npcsplike_content || "", page.data = cdata, pages.push(page), update.npcsplike_name = "", update.npcsplike_uniq = "", update.npcsplike_category = "", update.npcsplike_data = "", tmpupd = pfom.drop_add_spellike(objs, pages, {}, !1), _.extend(update, tmpupd);
                    let spellid = Object.keys(tmpupd)[0].substring(21, 41);
                    setAttrs(update, { silent: !0 }, () => { pfom.update_spells("like", spellid) })
                })
            }
        }
    }), on("change:npcspl0_data change:npcspl1_data change:npcspl2_data change:npcspl3_data change:npcspl4_data change:npcspl5_data change:npcspl6_data change:npcspl7_data change:npcspl8_data change:npcspl9_data", e => {
        if (e.newValue) {
            let cdata;
            try { cdata = JSON.parse(e.newValue) || {} } catch (error) { cdata = {} } if (!_.isEmpty(cdata)) {
                if ("spells" == cdata.Category.toLowerCase()) {
                    let level = e.sourceAttribute.substring(6, 7);
                    getAttrs([`npcspl${level}_name`, `npcspl${level}_uniq`, `npcspl${level}_content`], v => {
                        let objs = [], obj = {}, page = {}, pages = [], update = {}, tmpupd = {};
                        obj.name = v[`npcspl${level}_name`], obj.level = level, obj.spellcaster = "1", objs.push(obj), page.name = v[`npcspl${level}_name`], page.id = v[`npcspl${level}_uniq`], page.data = cdata, page.content = v[`npcspl${level}_content`] || "", pages.push(page), update[`npcspl${level}_name`] = "", update[`npcspl${level}_uniq`] = "", update[`npcspl${level}_category`] = "", update[`npcspl${level}_data`] = "", tmpupd = pfom.drop_add_spells(objs, pages, {}, !1), _.extend(update, tmpupd);
                        let spellid = Object.keys(tmpupd)[0].substring(18, 38);
                        setAttrs(update, { silent: !0 }, () => { pfom.update_spells(level, spellid) })
                    })
                }
            }
        }
    }), on("change:npcfeat_data", e => {
        if (e.newValue) {
            let cdata;
            try { cdata = JSON.parse(e.newValue) || {} } catch (error) { cdata = {} } if (!_.isEmpty(cdata)) {
                "feats" == cdata.Category.toLowerCase() && getAttrs(["npcfeat_name", "npcfeat_uniq", "npcfeat_content"], v => {
                    let objs = [], page = {}, pages = [], update = {}, tmpupd = {};
                    objs.push(v.npcfeat_name), page.name = v.npcfeat_name, page.id = v.npcfeat_uniq, page.content = v.npcfeat_content || "", page.data = cdata, pages.push(page), update.npcfeat_name = "", update.npcfeat_uniq = "", update.npcfeat_category = "", update.npcfeat_data = "", tmpupd = pfom.drop_add_feats(objs, pages, !1), _.extend(update, tmpupd), setAttrs(update, { silent: !0 })
                })
            }
        }
    });
var pfom = function () {
    const pfoglobals_currentversion = 1.303;
    var pfoglobals_i18n_obj = (obj = {}, obj.strength = getTranslationByKey("str-u"), obj.strength_mod = getTranslationByKey("str-u"), obj.strength_oneandahalf = getTranslationByKey("str-two-handed"), obj.strength_oneandahalf_mod = getTranslationByKey("str-two-handed"), obj.strength_half = getTranslationByKey("str-off-hand"), obj.strength_half_mod = getTranslationByKey("str-off-hand"), obj.dexterity = getTranslationByKey("dex-u"), obj.dexterity_mod = getTranslationByKey("dex-u"), obj.dexterity_oneandahalf = getTranslationByKey("dex-two-handed"), obj.dexterity_oneandahalf_mod = getTranslationByKey("dex-two-handed"), obj.dexterity_half = getTranslationByKey("dex-off-hand"), obj.dexterity_half_mod = getTranslationByKey("dex-off-hand"), obj.constitution = getTranslationByKey("con-u"), obj.constitution_mod = getTranslationByKey("con-u"), obj.intelligence = getTranslationByKey("int-u"), obj.intelligence_mod = getTranslationByKey("int-u"), obj.wisdom = getTranslationByKey("wis-u"), obj.wisdom_mod = getTranslationByKey("wis-u"), obj.charisma = getTranslationByKey("cha-u"), obj.charisma_mod = getTranslationByKey("cha-u"), obj.bab = getTranslationByKey("bab-u"), obj.bab_max = getTranslationByKey("bab-u"), obj.melee = getTranslationByKey("melee"), obj.melee_mod = getTranslationByKey("melee"), obj.ranged = getTranslationByKey("ranged"), obj.ranged_mod = getTranslationByKey("ranged"), obj.cmb = getTranslationByKey("cmb-u"), obj.cmb_mod = getTranslationByKey("cmb-u"), obj.fob = getTranslationByKey("fob"), obj.cmd = getTranslationByKey("cmd-u"), obj.ac = getTranslationByKey("ac-u"), obj.touch = getTranslationByKey("touch"), obj.flatfooted = getTranslationByKey("flat-footed"), obj.fftouch = getTranslationByKey("ff-touch"), obj.other = getTranslationByKey("other"), obj.fortitude = getTranslationByKey("fort-u"), obj.reflex = getTranslationByKey("ref-u"), obj.will = getTranslationByKey("will-u"), obj.vs = getTranslationByKey("vs"), obj[0] = "", obj.constant = getTranslationByKey("constant"), obj["at-will"] = getTranslationByKey("at-will"), obj["per-hour"] = getTranslationByKey("per-hour"), obj["per-day"] = getTranslationByKey("per-day"), obj["per-week"] = getTranslationByKey("per-week"), obj["per-month"] = getTranslationByKey("per-month"), obj["per-year"] = getTranslationByKey("per-year"), obj["every-hours"] = getTranslationByKey("every-hours"), obj.bleed = getTranslationByKey("bleed"), obj.dazed = getTranslationByKey("dazed"), obj.dying = getTranslationByKey("dying"), obj.fascinated = getTranslationByKey("fascinated"), obj.grappled = getTranslationByKey("grappled"), obj.nauseated = getTranslationByKey("nauseated"), obj.pinned = getTranslationByKey("pinned"), obj.stable = getTranslationByKey("stable"), obj.blinded = getTranslationByKey("blinded"), obj.dazzled = getTranslationByKey("dazzled"), obj.energy_drained = getTranslationByKey("energy_drained"), obj.fatigued = getTranslationByKey("fatigued"), obj.helpless = getTranslationByKey("helpless"), obj.panicked = getTranslationByKey("panicked"), obj.prone = getTranslationByKey("prone"), obj.staggered = getTranslationByKey("staggered"), obj.confused = getTranslationByKey("confused"), obj.deafened = getTranslationByKey("deafened"), obj.entangled = getTranslationByKey("entangled"), obj.frightened = getTranslationByKey("frightened"), obj.incorporeal = getTranslationByKey("incorporeal"), obj.paralyzed = getTranslationByKey("paralyzed"), obj.shaken = getTranslationByKey("shaken"), obj.stunned = getTranslationByKey("stunned"), obj.cowering = getTranslationByKey("cowering"), obj.disabled = getTranslationByKey("disabled"), obj.exhausted = getTranslationByKey("exhausted"), obj["flat-footed"] = getTranslationByKey("flat-footed"), obj.invisible = getTranslationByKey("invisible"), obj.petrified = getTranslationByKey("petrified"), obj.sickened = getTranslationByKey("sickened"), obj.unconscious = getTranslationByKey("unconscious"), obj.ability = getTranslationByKey("ability"), obj), obj, pfoglobals_initdone = 0;
    const pfoglobals_abilities = ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"], pfoglobals_abilities_fields = ["strength_base", "strength_race", "strength_bonus", "strength_condition", "dexterity_base", "dexterity_race", "dexterity_bonus", "dexterity_condition", "constitution_base", "constitution_race", "constitution_bonus", "intelligence_base", "intelligence_race", "intelligence_bonus", "wisdom_base", "wisdom_race", "wisdom_bonus", "charisma_base", "charisma_race", "charisma_bonus"], pfoglobals_mods = ["strength_mod", "dexterity_mod", "constitution_mod", "intelligence_mod", "wisdom_mod", "charisma_mod", "strength_base_mod", "dexterity_base_mod", "constitution_base_mod", "intelligence_base_mod", "wisdom_base_mod", "charisma_base_mod", "none_mod"], pfoglobals_flex_abilities = ["fortitude_ability", "reflex_ability", "will_ability", "cmb_ability", "melee_ability", "ranged_ability", "acrobatics_ability", "appraise_ability", "bluff_ability", "climb_ability", "craft_ability", "diplomacy_ability", "disable_device_ability", "disguise_ability", "escape_artist_ability", "fly_ability", "handle_animal_ability", "heal_ability", "intimidate_ability", "knowledge_arcana_ability", "knowledge_dungeoneering_ability", "knowledge_engineering_ability", "knowledge_geography_ability", "knowledge_history_ability", "knowledge_local_ability", "knowledge_nature_ability", "knowledge_nobility_ability", "knowledge_planes_ability", "knowledge_religion_ability", "linguistics_ability", "perception_ability", "perform_ability", "profession_ability", "ride_ability", "sense_motive_ability", "sleight_of_hand_ability", "spellcraft_ability", "stealth_ability", "survival_ability", "swim_ability", "use_magic_device_ability", "caster1_ability", "caster2_ability"], pfoglobals_initiative_fields = ["npc", "dexterity_mod", "initiative_misc", "initiative_bonus"], pfoglobals_ac_ability_fields = ["npc", "ac_ability_primary", "ac_ability_secondary", "ac_condition_nobonus", "ac_ability_mod", "encumbrance_ability_maximum", "ac_ability_maximum", "ac_secab_monk"].concat(pfoglobals_mods), pfoglobals_ac_fields = ["npc", "ac_bonus", "ac_ability_mod", "ac_armor", "ac_shield", "ac_size", "ac_misc", "ac_touch_items", "ac_flatfooted_items", "ac_natural_items", "ac_deflection_items", "ac_dodge_items", "ac_armor_bonus", "ac_shield_bonus", "ac_natural_bonus", "ac_deflection_bonus", "ac_dodge_bonus", "ac_noflatflooted", "ac_touchshield", "ac_condition", "ac_secab_monk", "ac_ff_ability_mod"], pfoglobals_save_attr = ["base", "ability", "ability_mod", "misc", "bonus"], pfoglobals_save_fields = ["fortitude_base", "fortitude_ability", "fortitude_ability_mod", "fortitude_misc", "fortitude_bonus", "reflex_base", "reflex_ability", "reflex_ability_mod", "reflex_misc", "reflex_bonus", "will_base", "will_ability", "will_ability_mod", "will_misc", "will_bonus"].concat(pfoglobals_mods), pfoglobals_babs_fields = ["npc", "bab", "bab_multi", "bab_size", "cmb_size", "cmb_ability", "cmb_ability_mod", "cmb_misc", "cmb_bonus", "melee_ability", "melee_ability_mod", "melee_misc", "melee_bonus", "ranged_ability", "ranged_ability_mod", "ranged_misc", "ranged_bonus", "ac_ability_mod", "ac_dodge_bonus", "ac_dodge_items", "ac_deflection_bonus", "ac_deflection_items", "cmd_misc", "cmd_bonus", "cmd_condition", "ac_condition_nobonus", "class1_name", "class2_name", "class3_name", "class1_bab", "class2_bab", "class3_bab", "class1_level", "class2_level", "class3_level"].concat(pfoglobals_mods), pfoglobals_skill_list = ["acrobatics", "appraise", "bluff", "climb", "craft", "diplomacy", "disable_device", "disguise", "escape_artist", "fly", "handle_animal", "heal", "intimidate", "knowledge_arcana", "knowledge_dungeoneering", "knowledge_engineering", "knowledge_geography", "knowledge_history", "knowledge_local", "knowledge_nature", "knowledge_nobility", "knowledge_planes", "knowledge_religion", "linguistics", "perception", "perform", "profession", "ride", "sense_motive", "sleight_of_hand", "spellcraft", "stealth", "survival", "swim", "use_magic_device"], pfoglobals_skill_attr = ["classkill", "ability", "ability_mod", "ranks", "misc", "bonus", "armor_penalty"], pfoglobals_skill_fields = ["skill_check_penalty", "armor_check_penalty", "encumbrance_check_penalty"].concat(pfoglobals_mods), pfoglobals_skillranks_fields = ["intelligence_mod", "class1_skillranks_misc", "class1_skillranks_base", "class2_skillranks_misc", "class2_skillranks_base", "class3_skillranks_misc", "class3_skillranks_base", "class1_level", "class2_level", "class3_level"];
    var pfoglobals_repsec_skills = [{ section: "skillcraft", attrs: pfoglobals_skill_attr }, { section: "skillknowledge", attrs: pfoglobals_skill_attr }, { section: "skillperform", attrs: pfoglobals_skill_attr }, { section: "skillprofession", attrs: pfoglobals_skill_attr }, { section: "skillcustom", attrs: pfoglobals_skill_attr }];
    const pfoglobals_atk_attr = ["atkname", "atkflag", "atktype", "atktype2", "atkmod", "atkvs", "atkrange", "atkcritrange", "dmgflag", "dmgbase", "dmgattr", "dmgmod", "dmgcritmulti", "dmgtype", "dmgbonusdice", "dmg2flag", "dmg2name", "dmg2base", "dmg2attr", "dmg2mod", "dmg2critmulti", "dmg2type", "dmg2bonusdice", "descflag", "atkdesc", "notes", "atkextra1flag", "atkextra1name", "atkextra1critrange", "atkextra1type", "atkextra1type2", "atkextra1mod", "atkextra1dmgbase", "atkextra1dmgattr", "atkextra1dmgmod", "atkextra1dmgtype", "atkextra1dmgcritmulti", "atkextra2flag", "atkextra2name", "atkextra2critrange", "atkextra2type", "atkextra2type2", "atkextra2mod", "atkextra2dmgbase", "atkextra2dmgattr", "atkextra2dmgmod", "atkextra2dmgtype", "atkextra2dmgcritmulti", "atkextra3flag", "atkextra3name", "atkextra3critrange", "atkextra3type", "atkextra3type2", "atkextra3mod", "atkextra3dmgbase", "atkextra3dmgattr", "atkextra3dmgmod", "atkextra3dmgtype", "atkextra3dmgcritmulti"];
    var pfoglobals_repsec_atk = [{ section: "attacks", attrs: pfoglobals_atk_attr }];
    const pfoglobals_atk_fields = ["npc", "strength_oneandahalf_mod", "strength_half_mod", "dexterity_oneandahalf_mod", "dexterity_half_mod", "melee_mod", "ranged_mod", "cmb_mod", "bab", "bab_max", "fob", "rollnotes_attack", "whispertype", "rollshowchar", "bab_multi", "melee_multi", "ranged_multi", "cmb_multi", "fob_multi", "attack_bonus", "damage_bonus", "melee_damage_bonus", "ranged_damage_bonus"].concat(pfoglobals_mods), pfoglobals_abilities_attr = ["perday", "perday_max", "perday_qty"], pfoglobals_repsec_traits = [{ section: "abilities", attrs: pfoglobals_abilities_attr }], pfoglobals_spell_attr = ["spelllevel", "spellcaster", "spellname", "spellschool", "spellclasslevel", "spellcastingtime", "spellrange", "spellarea", "spelltargets", "spelleffect", "spellduration", "spellsaveflag", "spellsave", "spelldc_mod", "spellresistanceflag", "spellresistance", "spellatkflag", "spellatktype", "spellatkmod", "spellatkcritrange", "spelldmgcritmulti", "spelldmgflag", "spelldmg", "spelldmgtype", "spelldmg2flag", "spelldmg2name", "spelldmg2", "spelldmg2type", "spelldescflag", "spelldesc", "notes"], pfoglobals_spell_only_attr = ["spellcomponent"], pfoglobals_spell_like_attr = ["spelltype", "timesperday", "perday_max", "perday_qty"];
    var pfoglobals_repsec_spell = [];
    const pfoglobals_spell_fields = ["melee_mod", "ranged_mod", "cmb_mod", "rollnotes_spell", "whispertype", "rollshowchar", "caster1_level", "caster2_level", "caster1_flag", "caster2_flag", "caster1_class", "caster2_class", "armor_spell_failure", "caster1_spell_failure", "caster2_spell_failure", "npc", "caster1_concentration_roll", "caster2_concentration_roll", "caster1_dc_level_0", "caster1_dc_level_1", "caster1_dc_level_2", "caster1_dc_level_3", "caster1_dc_level_4", "caster1_dc_level_5", "caster1_dc_level_6", "caster1_dc_level_7", "caster1_dc_level_8", "caster1_dc_level_9", "caster2_dc_level_0", "caster2_dc_level_1", "caster2_dc_level_2", "caster2_dc_level_3", "caster2_dc_level_4", "caster2_dc_level_5", "caster2_dc_level_6", "caster2_dc_level_7", "caster2_dc_level_8", "caster2_dc_level_9"].concat(pfoglobals_mods), pfoglobals_concentration_fields = ["npc", "caster1_level", "caster1_ability", "caster1_ability_mod", "caster1_concentration_misc", "caster1_concentration_bonus", "caster2_level", "caster2_ability", "caster2_ability_mod", "caster2_concentration_misc", "caster2_concentration_bonus"].concat(pfoglobals_mods), pfoglobals_spells_dc_fields = ["npc", "caster1_ability", "caster1_ability_mod", "caster1_dc_misc", "caster1_dcbonus_level_0", "caster1_dcbonus_level_1", "caster1_dcbonus_level_2", "caster1_dcbonus_level_3", "caster1_dcbonus_level_4", "caster1_dcbonus_level_5", "caster1_dcbonus_level_6", "caster1_dcbonus_level_7", "caster1_dcbonus_level_8", "caster1_dcbonus_level_9", "caster2_ability", "caster2_ability_mod", "caster2_dc_misc", "caster2_dcbonus_level_0", "caster2_dcbonus_level_1", "caster2_dcbonus_level_2", "caster2_dcbonus_level_3", "caster2_dcbonus_level_4", "caster2_dcbonus_level_5", "caster2_dcbonus_level_6", "caster2_dcbonus_level_7", "caster2_dcbonus_level_8", "caster2_dcbonus_level_9"].concat(pfoglobals_mods), pfoglobals_size = [{ size: "fine", atkac: 8, cmb: -8, fly: 8, stealth: 16, load: .125, squares: .5 }, { size: "diminutive", atkac: 4, cmb: -4, fly: 6, stealth: 12, load: .25, squares: .5 }, { size: "tiny", atkac: 2, cmb: -2, fly: 4, stealth: 8, load: .5, squares: .5 }, { size: "small", atkac: 1, cmb: -1, fly: 2, stealth: 4, load: .75, squares: .75 }, { size: "medium", atkac: 0, cmb: 0, fly: 0, stealth: 0, load: 1, squares: 1 }, { size: "large", atkac: -1, cmb: 1, fly: -2, stealth: -4, load: 2, squares: 2 }, { size: "huge", atkac: -2, cmb: 2, fly: -4, stealth: -8, load: 4, squares: 3 }, { size: "gargantuan", atkac: -4, cmb: 4, fly: -6, stealth: -12, load: 8, squares: 4 }, { size: "colossal", atkac: -8, cmb: 8, fly: -8, stealth: -16, load: 16, squares: 4 }], pfoglobals_encumbrance_fields = ["npc", "encumbrance_load_bonus", "encumbrance_load_multiplier", "strength", "encumbrance_size", "encumbrance_gear_weight", "encumbrance_load_light", "encumbrance_load_medium", "encumbrance_load_heavy", "speed_race", "speed_class", "encumbrance", "encumbrance_display"], pfoglobals_speed_fields = ["speed_race", "speed_class", "encumbrance", "speed_notmodified", "speed_encumbrance", "speed_armor", "encumbrance_run_factor", "armor_run_factor", "speed_base", "speed_bonus", "speed_run_factor", "speed_condition_multiplier", "speed_condition_norun", "speed_condition_nospeed", "speed_climb_misc", "speed_climb_bonus", "speed_swim_misc", "speed_swim_bonus"], pfoglobals_conditions = ["condition_bleed", "condition_blinded", "condition_confused", "condition_cowering", "condition_dazed", "condition_dazzled", "condition_deafened", "condition_disabled", "condition_dying", "condition_energy_drained", "condition_entangled", "condition_exhausted", "condition_fascinated", "condition_fatigued", "condition_flat-footed", "condition_frightened", "condition_grappled", "condition_helpless", "condition_incorporeal", "condition_invisible", "condition_nauseated", "condition_panicked", "condition_paralyzed", "condition_petrified", "condition_pinned", "condition_prone", "condition_shaken", "condition_sickened", "condition_stable", "condition_staggered", "condition_stunned", "condition_unconscious"], pfoglobals_buff_attr = ["name", "toggle", "mods"];
    var pfoglobals_repsec_buff = [{ section: "buff", attrs: pfoglobals_buff_attr }];
    const pfoglobals_allrepsecs = ["npcatk-melee", "npcatk-ranged", "npcatk-special", "feats", "abilities", "buff", "attacks", "skillcraft", "skillknowledge", "skillperform", "skillprofession", "skillcustom", "acitems", "gear", "feats", "abilities", "spell-0", "spell-1", "spell-2", "spell-3", "spell-4", "spell-5", "spell-6", "spell-7", "spell-8", "spell-9", "spell-like", "metamagic"], sheet_open = function (eventinfo) {
        if (0 == pfoglobals_initdone) {
            var obj = { section: "spell-like" };
            obj.attrs = pfoglobals_spell_attr.concat(pfoglobals_spell_like_attr), pfoglobals_repsec_spell.push(obj);
            for (var i = 0;
                i < 10;
                i++)(obj = {}).section = "spell-" + i, obj.attrs = pfoglobals_spell_attr.concat(pfoglobals_spell_only_attr), pfoglobals_repsec_spell.push(obj);
            setAttrs({ ask_modifier: getTranslationByKey("ask-modifier"), ask_atk_modifier: getTranslationByKey("ask-atk-modifier"), ask_dmg_modifier: getTranslationByKey("ask-dmg-modifier"), ask_whisper: getTranslationByKey("ask-whisper"), ask_public_roll: getTranslationByKey("ask-public-roll"), ask_whisper_roll: getTranslationByKey("ask-whisper-roll") }, { silent: !0 }, () => { pfoglobals_initdone = 1 })
        } (!eventinfo.sourceType || eventinfo.sourceType && "sheetworker" != eventinfo.sourceType) && versioning()
    }, reset_to_xpc = function (npcvalue) { setAttrs({ initialize_character_flag: 1, npc: npcvalue }, { silent: !0 }, () => { erase_repsec_ids(JSON.parse(JSON.stringify(pfoglobals_allrepsecs)), () => { setAttrs(calc_reset_character(), { silent: !0 }, npcvalue => { 0 == npcvalue ? le_big_stuff("all", {}, () => { versioning(), setAttrs({ initialize_character_flag: 0, npc_confirm_flag: 0 }, { silent: !0 }) }) : setAttrs({ initialize_character_flag: 0, npc_confirm_flag: 0, version: pfoglobals_currentversion }, { silent: !0 }) }) }) }) }, mancer_finish = function (eventinfo) {
        let mncrAbilities = pfoglobals_abilities, mancerdata = eventinfo.data, charUpd = {}, bRaceData = !1, bClassData = !1, FeatsToLoad = [], SpellsToLoad = [], allSpells = [], allTraits = [], allPowers = [], allClassSkills = "", allSkillBonus = "", skillBonusNotes = {}, finalRaceSpeed = 0, finalClassSpeed = 0, favoredbonus = 0;
        setCharmancerText({ mancer_category: "Resetting Attributes / Erasing Old Data", mancer_progress: '<div style="width: 4%"></div>' }), erase_repsec_ids(JSON.parse(JSON.stringify(pfoglobals_allrepsecs)), () => {
            (charUpd = calc_reset_character()).npc = 0, charUpd.tabcurrent = "tabmain", charUpd.l1mancer_status = "completed", setCharmancerText({ mancer_category: "Calculating Abilities", mancer_progress: '<div style="width: 8%"></div>' });
            let abilities_score = function (data) {
                let abilities_scores = {};
                if (_.each(mncrAbilities, ability => { abilities_scores[ability] = { total: 0, base: "0", race: "0", class: "0", subclass: "0", misc: "0" } }), data["l1-abilities"] && _.each(mncrAbilities, ability => { data["l1-abilities"].values[ability] && (abilities_scores[ability].base = parseInt(data["l1-abilities"].values[ability]) || 0) }), data["l1-race"] && (data["l1-race"].data && data["l1-race"].data.race && (data["l1-race"].data.race["data-Ability Score Modifiers"] ? _.each(data["l1-race"].data.race["data-Ability Score Modifiers"].split(","), modifier => {
                    let abrace = modifier.trim().toLowerCase();
                    abilities_scores[abrace.split(" ")[0].trim()] ? abilities_scores[abrace.split(" ")[0].trim()].race = parseInt(abrace.split(" ")[1]) || 0 : console.log("*** DEBUG ERROR ability race unsplitable: " + abrace)
                }) : data["l1-race"].data.race["data-Ability Score Choice"] && data["l1-race"].values.race_ability_choice1 && (abilities_scores[data["l1-race"].values.race_ability_choice1].race = parseInt(data["l1-race"].data.race["data-Ability Score Choice"].split("+")[1]) || 0)), "Index:Races" == data["l1-race"].values.race && _.each(mncrAbilities, ability => { data["l1-race"].values["race_" + ability] && (abilities_scores[ability].race = data["l1-race"].values["race_" + ability]) })), data["l1-class"] && data["l1-class"].values.class_subclass1_ability_choice) {
                    var sbclsablt = data["l1-class"].values.class_subclass1_ability_choice.split("(")[0].toLowerCase().trim(), sbclsabltvalue = data["l1-class"].values.class_subclass1_ability_choice.split("(")[1].replace(/[^\d\-]/gi, "");
                    abilities_scores[sbclsablt].subclass = parseInt(sbclsabltvalue) || 0
                } return _.each(mncrAbilities, ability => { abilities_scores[ability].total = (parseInt(abilities_scores[ability].base) || 0) + (parseInt(abilities_scores[ability].race) || 0) + (parseInt(abilities_scores[ability].class) || 0) + (parseInt(abilities_scores[ability].subclass) || 0) + (parseInt(abilities_scores[ability].misc) || 0) }), abilities_scores
            }(mancerdata), ability_mods = function (abilities_scores) {
                let ability_mods = {};
                return _.each(mncrAbilities, ability => { ability_mods[ability] = Math.floor(((parseInt(abilities_scores[ability].total) || 10) - 10) / 2) }), ability_mods
            }(abilities_score);
            if (_.each(mncrAbilities, ablt => { charUpd[ablt + "_base"] = parseInt(abilities_score[ablt].total) - parseInt(abilities_score[ablt].race), charUpd[ablt + "_race"] = parseInt(abilities_score[ablt].race), charUpd[ablt + "_mod"] = parseInt(ability_mods[ablt]) }), setCharmancerText({ mancer_category: "Applying Race", mancer_progress: '<div style="width: 16%"></div>' }), mancerdata["l1-race"] && mancerdata["l1-race"].values.race && ("Index:Races" == mancerdata["l1-race"].values.race ? (charUpd.race = mancerdata["l1-race"].values.race_custom_name || "Unknown", charUpd.size = mancerdata["l1-race"].values.race_custom_size || "medium", finalRaceSpeed += parseInt(mancerdata["l1-race"].values.race_custom_speed) || 30) : charUpd.race = mancerdata["l1-race"].values.race.replace("Races:", ""), mancerdata["l1-race"].data && mancerdata["l1-race"].data.race)) {
                if (bRaceData = !0, charUpd.size = mancerdata["l1-race"].data.race["data-Size"].toLowerCase().trim(), mancerdata["l1-race"].data.race["data-Race Speed"] && (finalRaceSpeed += parseInt(mancerdata["l1-race"].data.race["data-Race Speed"]) || 0), mancerdata["l1-race"].data.race["data-Speed Not Modified"] && (charUpd.speed_notmodified = 1), mancerdata["l1-race"].data.race["data-Senses"] && (charUpd.senses = mancerdata["l1-race"].data.race["data-Senses"]), mancerdata["l1-race"].data.race["data-Languages"] && (charUpd.languages += mancerdata["l1-race"].data.race["data-Languages"] + " "), mancerdata["l1-race"].data.race["data-AC Notes"] && (charUpd.ac_notes = mancerdata["l1-race"].data.race["data-AC Notes"]), mancerdata["l1-race"].data.race["data-Fortitude Notes"] && (charUpd.fortitude_notes += mancerdata["l1-race"].data.race["data-Fortitude Notes"] + " "), mancerdata["l1-race"].data.race["data-Reflex Notes"] && (charUpd.reflex_notes += mancerdata["l1-race"].data.race["data-Reflex Notes"] + " "), mancerdata["l1-race"].data.race["data-Will Notes"] && (charUpd.will_notes += mancerdata["l1-race"].data.race["data-Will Notes"] + " "), mancerdata["l1-race"].data.race["data-Skill Notes"] && -1 != mancerdata["l1-race"].data.race["data-Skill Notes"].indexOf(":") && (charUpd[mancerdata["l1-race"].data.race["data-Skill Notes"].split(":")[0].toLowerCase().trim() + "_notes"] += mancerdata["l1-race"].data.race["data-Skill Notes"].split(":")[1].trim()), mancerdata["l1-race"].data.race["data-Skills Bonus"] && (allSkillBonus += mancerdata["l1-race"].data.race["data-Skills Bonus"] + ",", skillBonusNotes[mancerdata["l1-race"].values.race.replace("Races:", "")] ? skillBonusNotes[mancerdata["l1-race"].values.race.replace("Races:", "")] += mancerdata["l1-race"].data.race["data-Skills Bonus"] + "," : skillBonusNotes[mancerdata["l1-race"].values.race.replace("Races:", "")] = mancerdata["l1-race"].data.race["data-Skills Bonus"] + ","), mancerdata["l1-race"].values.race_skill_bonus_choice && (allSkillBonus += mancerdata["l1-race"].values.race_skill_bonus_choice + ",", skillBonusNotes[mancerdata["l1-race"].values.race.replace("Races:", "")] ? skillBonusNotes[mancerdata["l1-race"].values.race.replace("Races:", "")] += mancerdata["l1-race"].values.race_skill_bonus_choice + "," : skillBonusNotes[mancerdata["l1-race"].values.race.replace("Races:", "")] = mancerdata["l1-race"].values.race_skill_bonus_choice + ","), mancerdata["l1-race"].data.race["data-Skill Ranks Bonus"] && (charUpd.class1_skillranks_base = (parseInt(charUpd.class1_skillranks_base) || 0) + (parseInt(mancerdata["l1-race"].data.race["data-Skill Ranks Bonus"].replace(/[^\d\-]/gi, "")) || 0)), mancerdata["l1-race"].values.race_feat_choice ? FeatsToLoad.push(mancerdata["l1-race"].values.race_feat_choice) : mancerdata["l1-race"].data.race["data-Feats"] && _.each(mancerdata["l1-race"].data.race["data-Feats"].split(","), feat => { FeatsToLoad.push("Feats:" + feat.trim()) }), mancerdata["l1-race"].data.race["data-Spell-like abilities"]) {
                    let splabz = "";
                    if (mancerdata["l1-race"].data.race["data-Spell-like abilities prerequisites"]) {
                        let ablt = (mancerdata["l1-race"].data.race["data-Spell-like abilities prerequisites"].split(" ")[0] || "").trim().toLowerCase(), minv = parseInt((mancerdata["l1-race"].data.race["data-Spell-like abilities prerequisites"].split(" ")[1] || "").trim().toLowerCase()) || 99;
                        (parseInt(abilities_score[ablt].total) || 0) >= minv && (splabz = mancerdata["l1-race"].data.race["data-Spell-like abilities"])
                    } else splabz = mancerdata["l1-race"].data.race["data-Spell-like abilities"];
                    splabz.length && (charUpd.caster1_flag = 1, charUpd.caster_flag = 1, _.each(splabz.split(","), splab => {
                        let pawa = {};
                        pawa.Name = splab.trim(), pawa.Type = "Sp", pawa["Spell-like"] = !0, pawa["Spell-source"] = splab.trim(), allPowers.push(pawa), SpellsToLoad.push("Spells:" + splab.trim())
                    }))
                } mancerdata["l1-race"].data.race["data-Traits"] && _.each(mancerdata["l1-race"].data.race["data-Traits"], trait => { trait.Type || (trait.Type = getTranslationByKey("race")), allTraits.push(trait) })
            } if (setCharmancerText({ mancer_category: "Applying Class", mancer_progress: '<div style="width: 24%"></div>' }), charUpd.level = 1, charUpd.class1_level = 1, mancerdata["l1-class"] && mancerdata["l1-class"].values.class && "Rules:Classes" != mancerdata["l1-class"].values.class) {
                if (charUpd.class1_name = mancerdata["l1-class"].values.class.replace("Classes:", ""), charUpd.class = charUpd.class1_name + " 1", mancerdata["l1-class"].values.favored_class && "0" != mancerdata["l1-class"].values.favored_class ? (charUpd.class1_favored = 1, charUpd.class_favored = 1, charUpd.class1_skillranks_misc = "1" == mancerdata["l1-class"].values.favored_class ? 1 : 0, favoredbonus = "2" == mancerdata["l1-class"].values.favored_class ? 1 : 0) : (charUpd.class1_favored = 0, charUpd.class_favored = 0), mancerdata["l1-class"].values.class_alignment_choice && (charUpd.alignment = mancerdata["l1-class"].values.class_alignment_choice.toLowerCase()), mancerdata["l1-class"].data && mancerdata["l1-class"].data.class) {
                    if (bClassData = !0, mancerdata["l1-class"].data.class["data-Hit Die"] && (charUpd.class1_hitdietype = mancerdata["l1-class"].data.class["data-Hit Die"].toLowerCase().replace("d", ""), charUpd.hitdietype = charUpd.class1_hitdietype, charUpd.hp_base = (parseInt(charUpd.class1_hitdietype) || 0) + (parseInt(ability_mods.constitution) || 0) + favoredbonus, charUpd.hp_base_max = charUpd.hp_base, charUpd.hp = charUpd.hp_base, charUpd.hp_max = charUpd.hp_base), mancerdata["l1-class"].data.class["data-Class skills"] && (allClassSkills += mancerdata["l1-class"].data.class["data-Class skills"] + ","), mancerdata["l1-class"].data.class["data-Skills bonus"] && (allSkillBonus += mancerdata["l1-class"].data.class["data-Skills bonus"] + ",", skillBonusNotes[mancerdata["l1-class"].values.class.replace("Classes:", "")] ? skillBonusNotes[mancerdata["l1-class"].values.class.replace("Classes:", "")] += mancerdata["l1-class"].data.class["data-Skills bonus"] + "," : skillBonusNotes[mancerdata["l1-class"].values.class.replace("Classes:", "")] = mancerdata["l1-class"].data.class["data-Skills bonus"] + ","), mancerdata["l1-class"].data.class["data-Skill Ranks"] && (charUpd.class1_skillranks_base = (parseInt(charUpd.class1_skillranks_base) || 0) + (parseInt(mancerdata["l1-class"].data.class["data-Skill Ranks"].split("+")[0].replace(/[^\d\-]/gi, "")) || 0)), mancerdata["l1-class"].values.class_wealth && "starting" == mancerdata["l1-class"].values.class_wealth && mancerdata["l1-class"].values.class_gp ? charUpd.money_gp = parseInt(mancerdata["l1-class"].values.class_gp) || 0 : mancerdata["l1-class"].data.class["data-Average Wealth"] && (charUpd.money_gp = parseInt(mancerdata["l1-class"].data.class["data-Average Wealth"].replace("gp", "").trim()) || 0), mancerdata["l1-class"].data.class["data-Base Attack Bonus"] && (charUpd.class1_bab = parseInt(mancerdata["l1-class"].data.class["data-Base Attack Bonus"]) || 0, charUpd.bab = charUpd.class1_bab), mancerdata["l1-class"].data.class["data-Speed bonus"] && (finalClassSpeed += parseInt(mancerdata["l1-class"].data.class["data-Speed bonus"]) || 0, charUpd.speed_notes += "+" + mancerdata["l1-class"].data.class["data-Speed bonus"] + " (" + charUpd.class1_name + ") "), mancerdata["l1-class"].data.class["data-AC Secondary Ability"] && (charUpd.ac_ability_secondary = mancerdata["l1-class"].data.class["data-AC Secondary Ability"].toLowerCase(), "Monk" == charUpd.class1_name && (charUpd.ac_secab_monk = 1)), mancerdata["l1-class"].data.class["data-Spellcaster"]) {
                        if (charUpd.caster1_flag = 1, charUpd.caster_flag = 1, charUpd.caster1_class = charUpd.class1_name, mancerdata["l1-class"].data.class["data-Spellcaster Level"] ? charUpd.caster1_level = parseInt(mancerdata["l1-class"].data.class["data-Spellcaster Level"]) || 0 : charUpd.caster1_level = 0, mancerdata["l1-class"].data.class["data-Spellcasting ability"] ? charUpd.caster1_ability = mancerdata["l1-class"].data.class["data-Spellcasting ability"].toLowerCase().trim() : charUpd.caster1_ability = "intelligence", mancerdata["l1-class"].data.class["data-Magic Type"] && (charUpd.caster1_spell_failure = "arcane" == mancerdata["l1-class"].data.class["data-Magic Type"].toLowerCase() ? 1 : 0), mancerdata["l1-class"].data.class["data-Spells Per Day"]) {
                            let i = -1;
                            _.each(mancerdata["l1-class"].data.class["data-Spells Per Day"].split(","), qty => { charUpd["caster1_spells_perday_level_" + ++i] = parseInt(qty.trim()) || 0, charUpd["caster1_spells_total_level_" + i] = charUpd["caster1_spells_perday_level_" + i], charUpd["caster_spells_flag_level_" + i] = 1 })
                        } let spellablt = parseInt(abilities_score[charUpd.caster1_ability].total) || 10;
                        if (charUpd.caster1_spells_bonus_level_1 = spellablt > 11 && spellablt < 20 ? 1 : spellablt > 19 ? 2 : 0, charUpd.caster1_spells_total_level_1 = (parseInt(charUpd.caster1_spells_total_level_1) || 0) + parseInt(charUpd.caster1_spells_bonus_level_1), mancerdata["l1-class"].data.class["data-Spells Known"]) {
                            let i = -1;
                            _.each(mancerdata["l1-class"].data.class["data-Spells Known"].split(","), qty => { i++, -1 == qty.indexOf("+") ? charUpd["caster1_spells_known_level_" + i] = parseInt(qty.trim()) || 0 : charUpd["caster1_spells_known_level_" + i] = (parseInt(qty.split("+")[0].toLowerCase().trim()) || 0) + (parseInt(ability_mods[qty.split("+")[1].toLowerCase().trim()]) || 0), charUpd["caster_spells_flag_level_" + i] = 1 })
                        } mancerdata["l1-class"].data.class["data-Spell-like abilities"] && _.each(mancerdata["l1-class"].data.class["data-Spell-like abilities"].split(","), splab => {
                            let pawa = {};
                            pawa.Name = splab.trim(), pawa.Type = "Sp", pawa["Spell-like"] = !0, pawa["Spell-source"] = splab.trim(), allPowers.push(pawa), SpellsToLoad.push("Spells:" + splab.trim())
                        })
                    } mancerdata["l1-class"].data.class["data-Languages"] && (charUpd.languages += mancerdata["l1-class"].data.class["data-Languages"] + " "), mancerdata["l1-class"].data.class["data-Bonus Feats"] && _.each(mancerdata["l1-class"].data.class["data-Bonus Feats"].split(","), feat => { FeatsToLoad.push("Feats:" + feat.trim()) }), mancerdata["l1-class"].values.class_feat_choice && FeatsToLoad.push(mancerdata["l1-class"].values.class_feat_choice), mancerdata["l1-class"].data.class["data-Traits"] && (allTraits = allTraits.concat(mancerdata["l1-class"].data.class["data-Traits"]))
                } for (let subcls = 1;
                    subcls < 3;
                    subcls++)mancerdata["l1-class"].values["class_subclass" + subcls] && (charUpd.caster1_spells_notes += mancerdata["l1-class"].data.class["data-Subclass Name"] + ": " + mancerdata["l1-class"].values["class_subclass" + subcls].replace("Subclasses:", "") + ", ", mancerdata["l1-class"].data["class_subclass" + subcls] && (mancerdata["l1-class"].data["class_subclass" + subcls]["data-Ability bonus choice"], mancerdata["l1-class"].data["class_subclass" + subcls]["data-Saving Throws bonus"] && (charUpd.fortitude_notes += mancerdata["l1-class"].data["class_subclass" + subcls]["data-Saving Throws bonus"] + " (" + mancerdata["l1-class"].data.class["data-Subclass Name"] + ": " + mancerdata["l1-class"].values["class_subclass" + subcls].replace("Subclasses:", "") + "). ", charUpd.reflex_notes += charUpd.fortitude_notes, charUpd.will_notes += charUpd.fortitude_notes), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Initiative Bonus"] && (charUpd.initiative_misc += (parseInt(charUpd.initiative_misc) || 0) + (parseInt(mancerdata["l1-class"].data["class_subclass" + subcls]["data-Initiative Bonus"]) || 0), charUpd.initiative_notes += "+" + mancerdata["l1-class"].data["class_subclass" + subcls]["data-Initiative Bonus"] + " (" + mancerdata["l1-class"].data.class["data-Subclass Name"] + ": " + mancerdata["l1-class"].values["class_subclass" + subcls].replace("Subclasses:", "") + "). "), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Base Speed Bonus"] && (finalClassSpeed += parseInt(mancerdata["l1-class"].data["class_subclass" + subcls]["data-Base Speed Bonus"]) || 0, charUpd.speed_notes += "+" + mancerdata["l1-class"].data["class_subclass" + subcls]["data-Base Speed Bonus"] + " (" + mancerdata["l1-class"].data.class["data-Subclass Name"] + ": " + mancerdata["l1-class"].values["class_subclass" + subcls].replace("Subclasses:", "") + ") "), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Class skills"] && (allClassSkills += mancerdata["l1-class"].data["class_subclass" + subcls]["data-Class skills"] + ","), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Skills bonus"] && (allSkillBonus += mancerdata["l1-class"].data["class_subclass" + subcls]["data-Skills bonus"] + ",", skillBonusNotes[mancerdata["l1-class"].data.class["data-Subclass Name"] + ": " + mancerdata["l1-class"].values["class_subclass" + subcls].replace("Subclasses:", "")] ? skillBonusNotes[mancerdata["l1-class"].data.class["data-Subclass Name"] + ": " + mancerdata["l1-class"].values["class_subclass" + subcls].replace("Subclasses:", "")] += mancerdata["l1-class"].data["class_subclass" + subcls]["data-Skills bonus"] + "," : skillBonusNotes[mancerdata["l1-class"].data.class["data-Subclass Name"] + ": " + mancerdata["l1-class"].values["class_subclass" + subcls].replace("Subclasses:", "")] = mancerdata["l1-class"].data["class_subclass" + subcls]["data-Skills bonus"] + ","), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Bonus Feat"] && _.each(mancerdata["l1-class"].data["class_subclass" + subcls]["data-Bonus Feat"].split(","), feat => { FeatsToLoad.push("Feats:" + feat.trim()) }), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Domain Spells Level 1"] && _.each(mancerdata["l1-class"].data["class_subclass" + subcls]["data-Domain Spells Level 1"].split(","), spell => {
                        let spl = {};
                        spl.name = spell.trim(), spl.level = 1, spl.domain = !0, allSpells.push(spl), SpellsToLoad.push("Spells:" + spell.trim())
                    }), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Traits"] && (allTraits = allTraits.concat(mancerdata["l1-class"].data["class_subclass" + subcls]["data-Traits"])), mancerdata["l1-class"].data["class_subclass" + subcls]["data-Powers"] && (allPowers = allPowers.concat(mancerdata["l1-class"].data["class_subclass" + subcls]["data-Powers"]), _.each(mancerdata["l1-class"].data["class_subclass" + subcls]["data-Powers"], pawa => { pawa["Spell-source"] && SpellsToLoad.push("Spells:" + pawa["Spell-source"]) }))))
            } setCharmancerText({ mancer_category: "Calculation Speed", mancer_progress: '<div style="width: 32%"></div>' }), charUpd.speed_race = finalRaceSpeed, charUpd.class1_speed = finalClassSpeed, charUpd.speed_class = finalClassSpeed, setCharmancerText({ mancer_category: "Calculation Saving Throws", mancer_progress: '<div style="width: 40%"></div>' });
            let saves_array = [{ name: "fortitude", ability: "constitution" }, { name: "reflex", ability: "dexterity" }, { name: "will", ability: "wisdom" }], saves_scores = {};
            _.each(saves_array, save => { saves_scores[save.name] = { total: 0, base: 0, race: 0, class: 0, subclass: 0, misc: 0, ability: save.ability } }), mancerdata["l1-abilities"] && _.each(saves_array, save => { saves_scores[save.name].base = ability_mods[save.ability] }), bRaceData && _.each(saves_array, save => { mancerdata["l1-race"].data.race["data-" + save.name.charAt(0).toUpperCase() + save.name.slice(1) + " Bonus"] && (saves_scores[save.name].race = parseInt(mancerdata["l1-race"].data.race["data-" + save.name.charAt(0).toUpperCase() + save.name.slice(1) + " Bonus"]) || 0, charUpd[save.name + "_notes"] += "+" + saves_scores[save.name].race + " (" + charUpd.race + "). ") }), bClassData && (mancerdata["l1-class"].data.class["data-Fortitude"] && (saves_scores.fortitude.class = parseInt(mancerdata["l1-class"].data.class["data-Fortitude"]) || 0), mancerdata["l1-class"].data.class["data-Reflex"] && (saves_scores.reflex.class = parseInt(mancerdata["l1-class"].data.class["data-Reflex"]) || 0), mancerdata["l1-class"].data.class["data-Will"] && (saves_scores.will.class = parseInt(mancerdata["l1-class"].data.class["data-Will"]) || 0));
            let subclsvbonus = 0;
            if (mancerdata["l1-class"].values.class_subclass1 && mancerdata["l1-class"].data && mancerdata["l1-class"].data.class_subclass1 && mancerdata["l1-class"].data.class_subclass1["data-Saving Throws bonus"] && (subclsvbonus = parseInt(mancerdata["l1-class"].data.class_subclass1["data-Saving Throws bonus"].replace(/[^\d\-]/gi, "")) || 0, _.each(saves_array, save => { saves_scores[save.name].subclass = parseInt(saves_scores[save.name].subclass) + subclsvbonus })), mancerdata["l1-class"].values.class_subclass2 && mancerdata["l1-class"].data && mancerdata["l1-class"].data.class_subclass2 && mancerdata["l1-class"].data.class_subclass2["data-Saving Throws bonus"] && (subclsvbonus = parseInt(mancerdata["l1-class"].data.class_subclass2["data-Saving Throws bonus"].replace(/[^\d\-]/gi, "")) || 0, _.each(saves_array, save => { saves_scores[save.name].subclass = parseInt(saves_scores[save.name].subclass) + subclsvbonus })), _.each(saves_array, save => { saves_scores[save.name].total = (parseInt(saves_scores[save.name].base) || 0) + (parseInt(saves_scores[save.name].race) || 0) + (parseInt(saves_scores[save.name].class) || 0) + (parseInt(saves_scores[save.name].subclass) || 0) + (parseInt(saves_scores[save.name].misc) || 0), charUpd["class1_" + save.name] = (parseInt(saves_scores[save.name].class) || 0) + (parseInt(saves_scores[save.name].subclass) || 0), charUpd[save.name + "_base"] = charUpd["class1_" + save.name], charUpd[save.name + "_ability_mod"] = saves_scores[save.name].base, charUpd[save.name + "_misc"] = (parseInt(saves_scores[save.name].race) || 0) + (parseInt(saves_scores[save.name].misc) || 0), charUpd[save.name] = saves_scores[save.name].total }), setCharmancerText({ mancer_category: "Calculation Skills", mancer_progress: '<div style="width: 44%"></div>' }), allClassSkills.length && _.each(allClassSkills.split(","), cls => { cls.trim().toLowerCase().replace(/[^a-z\s]/gi, "").replace(/\s/gi, "_").length && (charUpd[cls.trim().toLowerCase().replace(/[^a-z\s]/gi, "").replace(/\s/gi, "_") + "_classkill"] = 1) }), allSkillBonus.length && _.each(allSkillBonus.split(","), skl => {
                if (-1 != skl.indexOf("+")) {
                    let skill = skl.split("+")[0].trim().toLowerCase().replace(/[^a-z\s]/gi, "").trim().replace(/\s/gi, "_");
                    charUpd[skill + "_misc"] = (parseInt(charUpd[skill + "_misc"]) || 0) + (parseInt(skl.split("+")[1].replace(/[^\d\-]/gi, "")) || 0)
                }
            }), mancerdata["l1-skills"] && mancerdata["l1-skills"].values && _.each(Object.keys(mancerdata["l1-skills"].values), skl => { "_ranks" == skl.slice(-6) && (charUpd[skl] = mancerdata["l1-skills"].values[skl]) }), _.isEmpty(skillBonusNotes) || _.each(Object.keys(skillBonusNotes), key => {
                skillBonusNotes[key] && _.each(skillBonusNotes[key].split(","), skl => {
                    if (-1 != skl.indexOf("+")) {
                        let skill = skl.split("+")[0].trim().toLowerCase().replace(/[^a-z\s]/gi, "").trim().replace(/\s/gi, "_");
                        charUpd[skill + "_notes"] += "+" + skl.split("+")[1].replace(/[^\d\-]/gi, "") + " (" + key + "). "
                    }
                })
            }), mancerdata["l1-feats"] && mancerdata["l1-feats"].values.feat_lvl1_1 && FeatsToLoad.push(mancerdata["l1-feats"].values.feat_lvl1_1), mancerdata["l1-spells"] && mancerdata["l1-spells"].values) for (let j = 0;
                    j < 2;
                    j++)for (let i = 1;
                        i < 10;
                        i++)mancerdata["l1-spells"].values["spells_level_" + j + "_" + i] && (allSpells.push({ name: mancerdata["l1-spells"].values["spells_level_" + j + "_" + i], level: j }), SpellsToLoad.push(mancerdata["l1-spells"].values["spells_level_" + j + "_" + i]));
            if (setCharmancerText({ mancer_category: "Adding Traits", mancer_progress: '<div style="width: 48%"></div>' }), _.each(allTraits, trait => {
                if (trait.Name) {
                    let sec = "repeating_abilities_" + generateRowID() + "_";
                    if (charUpd[sec + "name"] = trait.Name, charUpd[sec + "options-flag"] = 0, trait.Type && (charUpd[sec + "type"] = trait.Type), trait["Per-day"]) {
                        let perday = 0;
                        (perday = -1 == trait["Per-day"].indexOf("+") ? parseInt(trait["Per-day"]) || 1 : (parseInt(trait["Per-day"].split("+")[0].replace(/[^\d]/gi, "").trim()) || 1) + (parseInt(ability_mods[trait["Per-day"].split("+")[1].replace("modifier", "").trim().toLowerCase()]) || 0)) > 0 && (charUpd[sec + "perday_qty"] = perday, charUpd[sec + "perday_max"] = perday)
                    } trait.Description && (charUpd[sec + "description"] = trait.Description)
                }
            }), bClassData && "monk" == charUpd.class1_name.toLowerCase()) {
                let attackid = generateRowID();
                charUpd["repeating_attacks_" + attackid + "_atkname"] = getTranslationByKey("fob"), charUpd["repeating_attacks_" + attackid + "_atktype"] = "fob", charUpd["repeating_attacks_" + attackid + "_atktype2"] = "strength", charUpd["repeating_attacks_" + attackid + "_dmgbase"] = "1d6", charUpd["repeating_attacks_" + attackid + "_dmgattr"] = "strength", charUpd["repeating_attacks_" + attackid + "_options-flag"] = "0"
            } setCharmancerText({ mancer_category: "Loading New Data", mancer_progress: '<div style="width: 64%"></div>' });
            let allCompendiumPages = [];
            allCompendiumPages = allCompendiumPages.concat(FeatsToLoad, SpellsToLoad), getCompendiumPage(allCompendiumPages, compendiumdata => {
                let cdatarr;
                "object" == typeof compendiumdata ? cdatarr = Object.values(compendiumdata) : Array.isArray(compendiumdata) ? cdatarr = compendiumdata : (cdatarr = []).push(compendiumdata), setCharmancerText({ mancer_category: "Adding Feats", mancer_progress: '<div style="width: 72%"></div>' }), FeatsToLoad.length && _.extend(charUpd, drop_add_feats(FeatsToLoad, cdatarr, !0)), setCharmancerText({ mancer_category: "Adding Powers", mancer_progress: '<div style="width: 80%"></div>' }), allPowers.length && _.extend(charUpd, drop_add_spellike(allPowers, cdatarr, charUpd, !0)), setCharmancerText({ mancer_category: "Adding Spells", mancer_progress: '<div style="width: 88%"></div>' }), SpellsToLoad.length && _.extend(charUpd, drop_add_spells(allSpells, cdatarr, charUpd, !0)), setAttrs(charUpd, { silent: !0 }, () => { setCharmancerText({ mancer_category: "Global update", mancer_progress: '<div style="width: 100%"></div>' }), le_big_stuff("all", {}, () => { update_ac_items(), update_coins_weight(), finishCharactermancer() }) })
            })
        })
    }, update_npc_drop = function (cdata, attrs, callback) {
        var update = {};
        update.version = pfoglobals_currentversion, update.l1mancer_status = "completed", update.npc = 1, update["options-flag-npc"] = 0, setAttrs(update, { silent: !0 }, () => {
            update = {};
            var objspells, objlikes, tmpobj = {};
            if (attrs.npcdrop_name && (update.character_name = attrs.npcdrop_name), attrs.npcdrop_uniq ? update.npc_fromcompendium = attrs.npcdrop_uniq : update.npc_fromcompendium = "Bestiary:" + attrs.npcdrop_name, update.armor_spell_failure = 0, cdata["icon-Climate"] && (update.npc_icon_climate = cdata["icon-Climate"].toLowerCase().trim()), cdata["icon-Terrain"] && (update.npc_icon_terrain = cdata["icon-Terrain"].toLowerCase().trim()), cdata["icon-CreatureType"] && (update.npc_icon_type = cdata["icon-CreatureType"].toLowerCase().trim()), (cdata.Expansion || cdata.expansion) && (update.npc_expansion = cdata.Expansion || cdata.expansion), cdata["data-Size"] && (["fine", "diminutive", "tiny", "small", "medium", "large", "huge", "gargantuan", "colossal"].includes(cdata["data-Size"].toLowerCase()) ? (update.size = cdata["data-Size"].toLowerCase(), update.size_display = getTranslationByKey(cdata["data-Size"].toLowerCase())) : update.size_display = cdata["data-Size"]), cdata["data-Spell Caster Level"] && (update.caster1_level = parseInt(cdata["data-Spell Caster Level"]) || 0), cdata["data-Spell Caster Concentration"] && (update.caster1_concentration = parseInt(cdata["data-Spell Caster Concentration"]) || 0), cdata["data-Spells"]) { try { objspells = JSON.parse(cdata["data-Spells"]) } catch (error) { objspells = [] } update.spells_flag = 1 } else cdata["data-Spells Misc"] ? (objspells = [], update.npc_spells_notes = cdata["data-Spells Misc"], update.spells_flag = 1) : (objspells = [], update.spells_flag = 0);
            for (var i = 1;
                i < 10;
                i++)cdata["data-Spells per day-Level " + i] && (update["caster1_spells_perday_level_" + i] = parseInt(cdata["data-Spells per day-Level " + i]) || 0, update["caster1_spells_total_level_" + i] = parseInt(cdata["data-Spells per day-Level " + i]) || 0);
            if (objspells.length) {
                var spellsbylevel = objspells.reduce(function (sums, entry) { return sums[entry.level] = (sums[entry.level] || 0) + 1, sums }, {});
                for (i = 1;
                    i < 10;
                    i++)spellsbylevel["" + i] && !update["caster1_spells_perday_level_" + i] && (update["caster1_spells_perday_level_" + i] = spellsbylevel["" + i], update["caster1_spells_total_level_" + i] = spellsbylevel["" + i])
            } if (cdata["data-Bloodlines Domains Schools"] && (update.caster1_spells_notes = cdata["data-Bloodlines Domains Schools"]), cdata["data-Spell-Like Abilities Caster Level"] && (update.caster2_level = parseInt(cdata["data-Spell-Like Abilities Caster Level"]) || 0), cdata["data-Spell-Like Abilities Concentration"] && (update.caster2_concentration = parseInt(cdata["data-Spell-Like Abilities Concentration"]) || 0), cdata["data-Spell-like Abilities"]) { try { objlikes = JSON.parse(cdata["data-Spell-like Abilities"]) } catch (error) { objlikes = [] } update.spellabilities_flag = 1 } else cdata["data-Spell-Like Abilities Misc"] ? (objlikes = [], update.npc_spellabilities_notes = cdata["data-Spell-Like Abilities Misc"], update.spellabilities_flag = 1) : (objlikes = [], update.spellabilities_flag = 0);
            if (cdata["data-CR"] && (update.npc_cr = cdata["data-CR"]), cdata["data-MR"] && (update.npc_mr = cdata["data-MR"]), cdata["data-XP"] && (update.xp = cdata["data-XP"]), cdata["data-Race Class Level"] && (update.class = cdata["data-Race Class Level"]), cdata["data-Alignment"] && (update.npc_alignment = cdata["data-Alignment"]), cdata["data-Type"] && (update.npc_type = cdata["data-Type"]), cdata["data-Initiative"] && (update.initiative = parseInt(cdata["data-Initiative"]) || 0), cdata["data-Initiative Notes"] && (update.initiative_notes = "(" + cdata["data-Initiative Notes"] + ")"), cdata["data-Senses"] && (update.senses = cdata["data-Senses"]), cdata["data-Aura"] && (update.aura = cdata["data-Aura"]), cdata["data-AC"] && (update.ac = parseInt(cdata["data-AC"]) || 0), cdata["data-AC Touch"] && (update.ac_touch = parseInt(cdata["data-AC Touch"]) || 0), cdata["data-AC Flat-Footed"] && (update.ac_flatfooted = parseInt(cdata["data-AC Flat-Footed"]) || 0), cdata["data-AC Notes"] && (update.ac_notes = cdata["data-AC Notes"]), cdata["data-HP"] && (update.hp = parseInt(cdata["data-HP"]) || 0, update.hp_max = parseInt(cdata["data-HP"]) || 0), cdata["data-HP Notes"] && (update.hp_notes = cdata["data-HP Notes"]), cdata["data-HP Roll"] && (update.hd_roll = cdata["data-HP Roll"]), cdata["data-HD"] && (update.hd = cdata["data-HD"]), cdata["data-Fort"] && (update.fortitude = parseInt(cdata["data-Fort"]) || 0), cdata["data-Ref"] && (update.reflex = parseInt(cdata["data-Ref"]) || 0), cdata["data-Will"] && (update.will = parseInt(cdata["data-Will"]) || 0), cdata["data-Save Modifiers"] && (update.saves_modifiers = cdata["data-Save Modifiers"]), cdata["data-SR"] && (update.sr = parseInt(cdata["data-SR"]) || 0), cdata["data-Defensive Abilities"] && (update.defensive_abilities = cdata["data-Defensive Abilities"]), cdata["data-DR"] && (update.npc_dr = cdata["data-DR"]), cdata["data-Immunities"] && (update.immune = cdata["data-Immunities"]), cdata["data-Resistances"] && (update.resist = cdata["data-Resistances"]), cdata["data-Weaknesses"] && (update.weaknesses = cdata["data-Weaknesses"]), cdata["data-Speed"] && (update.npc_speed = cdata["data-Speed"]), cdata["data-Space"] && (update.space = cdata["data-Space"]), cdata["data-Reach"] && (update.reach = cdata["data-Reach"]), cdata["data-Tactics"] && (update.tactics = cdata["data-Tactics"]), cdata["data-STR"] ? update.strength = parseInt(cdata["data-STR"]) || "-" : update.strength = "-", tmpobj = calc_ability_mod("strength", update), _.extend(update, tmpobj), cdata["data-DEX"] ? update.dexterity = parseInt(cdata["data-DEX"]) || "-" : update.dexterity = "-", tmpobj = calc_ability_mod("dexterity", update), _.extend(update, tmpobj), cdata["data-CON"] ? update.constitution = parseInt(cdata["data-CON"]) || "-" : update.constitution = "-", tmpobj = calc_ability_mod("constitution", update), _.extend(update, tmpobj), cdata["data-INT"] ? update.intelligence = parseInt(cdata["data-INT"]) || "-" : update.intelligence = "-", tmpobj = calc_ability_mod("intelligence", update), _.extend(update, tmpobj), cdata["data-WIS"] ? update.wisdom = parseInt(cdata["data-WIS"]) || "-" : update.wisdom = "-", tmpobj = calc_ability_mod("wisdom", update), _.extend(update, tmpobj), cdata["data-CHA"] ? update.charisma = parseInt(cdata["data-CHA"]) || "-" : update.charisma = "-", tmpobj = calc_ability_mod("charisma", update), _.extend(update, tmpobj), cdata["data-Base Atk"] ? update.bab = parseInt(cdata["data-Base Atk"]) || 0 : update.bab = 0, cdata["data-CMB"] ? update.cmb_mod = parseInt(cdata["data-CMB"]) || 0 : update.cmb_mod = 0, cdata["data-CMB Notes"] && (update.cmb_notes = cdata["data-CMB Notes"]), cdata["data-CMD"] ? update.cmd_mod = parseInt(cdata["data-CMD"]) || 0 : update.cmd_mod = 0, cdata["data-CMD Notes"] && (update.cmd_notes = cdata["data-CMD Notes"]), cdata["data-Skills Racial Modifiers"] && (update.skills_racial_modifiers = cdata["data-Skills Racial Modifiers"]), cdata["data-Acrobatics"] && (update.acrobatics = parseInt(cdata["data-Acrobatics"]) || 0), cdata["data-Acrobatics Notes"] && (update.acrobatics_notes = cdata["data-Acrobatics Notes"]), _.extend(update, calc_npc_skill_display("acrobatics", cdata["data-Acrobatics"] || "", cdata["data-Acrobatics Notes"] || "")), cdata["data-Appraise"] && (update.appraise = parseInt(cdata["data-Appraise"]) || 0), cdata["data-Appraise Notes"] && (update.appraise_notes = cdata["data-Appraise Notes"]), _.extend(update, calc_npc_skill_display("appraise", cdata["data-Appraise"] || "", cdata["data-Appraise Notes"] || "")), cdata["data-Bluff"] && (update.bluff = parseInt(cdata["data-Bluff"]) || 0), cdata["data-Bluff Notes"] && (update.bluff_notes = cdata["data-Bluff Notes"]), _.extend(update, calc_npc_skill_display("bluff", cdata["data-Bluff"] || "", cdata["data-Bluff Notes"] || "")), cdata["data-Climb"] && (update.climb = parseInt(cdata["data-Climb"]) || 0), cdata["data-Climb Notes"] && (update.climb_notes = cdata["data-Climb Notes"]), _.extend(update, calc_npc_skill_display("climb", cdata["data-Climb"] || "", cdata["data-Climb Notes"] || "")), cdata["data-Craft"] && (update.craft = parseInt(cdata["data-Craft"]) || 0), cdata["data-Craft Notes"] && (update.craft_notes = cdata["data-Craft Notes"]), _.extend(update, calc_npc_skill_display("craft", cdata["data-Craft"] || "", cdata["data-Craft Notes"] || "")), cdata["data-Diplomacy"] && (update.diplomacy = parseInt(cdata["data-Diplomacy"]) || 0), cdata["data-Diplomacy Notes"] && (update.diplomacy_notes = cdata["data-Diplomacy Notes"]), _.extend(update, calc_npc_skill_display("diplomacy", cdata["data-Diplomacy"] || "", cdata["data-Diplomacy Notes"] || "")), cdata["data-Disable Device"] && (update.disable_device = parseInt(cdata["data-Disable Device"]) || 0), cdata["data-Disable Device Notes"] && (update.disable_device_notes = cdata["data-Disable Device Notes"]), _.extend(update, calc_npc_skill_display("disable_device", cdata["data-Disable Device"] || "", cdata["data-Disable Device Notes"] || "")), cdata["data-Disguise"] && (update.disguise = parseInt(cdata["data-Disguise"]) || 0), cdata["data-Disguise Notes"] && (update.disguise_notes = cdata["data-Disguise Notes"]), _.extend(update, calc_npc_skill_display("disguise", cdata["data-Disguise"] || "", cdata["data-Disguise Notes"] || "")), cdata["data-Escape Artist"] && (update.escape_artist = parseInt(cdata["data-Escape Artist"]) || 0), cdata["data-Escape Artist Notes"] && (update.escape_artist_notes = cdata["data-Escape Artist Notes"]), _.extend(update, calc_npc_skill_display("escape_artist", cdata["data-Escape Artist"] || "", cdata["data-Escape Artist Notes"] || "")), cdata["data-Fly"] && (update.fly = parseInt(cdata["data-Fly"]) || 0), cdata["data-Fly Notes"] && (update.fly_notes = cdata["data-Fly Notes"]), _.extend(update, calc_npc_skill_display("fly", cdata["data-Fly"] || "", cdata["data-Fly Notes"] || "")), cdata["data-Handle Animal"] && (update.handle_animal = parseInt(cdata["data-Handle Animal"]) || 0), cdata["data-Handle Animal Notes"] && (update.handle_animal_notes = cdata["data-Handle Animal Notes"]), _.extend(update, calc_npc_skill_display("handle_animal", cdata["data-Handle Animal"] || "", cdata["data-Handle Animal Notes"] || "")), cdata["data-Heal"] && (update.heal = parseInt(cdata["data-Heal"]) || 0), cdata["data-Heal Notes"] && (update.heal_notes = cdata["data-Heal Notes"]), _.extend(update, calc_npc_skill_display("heal", cdata["data-Heal"] || "", cdata["data-Heal Notes"] || "")), cdata["data-Intimidate"] && (update.intimidate = parseInt(cdata["data-Intimidate"]) || 0), cdata["data-Intimidate Notes"] && (update.intimidate_notes = cdata["data-Intimidate Notes"]), _.extend(update, calc_npc_skill_display("intimidate", cdata["data-Intimidate"] || "", cdata["data-Intimidate Notes"] || "")), cdata["data-Knowledge Arcana"] && (update.knowledge_arcana = parseInt(cdata["data-Knowledge Arcana"]) || 0), cdata["data-Knowledge Arcana Notes"] && (update.knowledge_arcana_notes = cdata["data-Knowledge Arcana Notes"]), _.extend(update, calc_npc_skill_display("knowledge_arcana", cdata["data-Knowledge Arcana"] || "", cdata["data-Knowledge Arcana Notes"] || "")), cdata["data-Knowledge Dungeoneering"] && (update.knowledge_dungeoneering = parseInt(cdata["data-Knowledge Dungeoneering"]) || 0), cdata["data-Knowledge Dungeoneering Notes"] && (update.knowledge_dungeoneering_notes = cdata["data-Knowledge Dungeoneering Notes"]), _.extend(update, calc_npc_skill_display("knowledge_dungeoneering", cdata["data-Knowledge Dungeoneering"] || "", cdata["data-Knowledge Dungeoneering Notes"] || "")), cdata["data-Knowledge Engineering"] && (update.knowledge_engineering = parseInt(cdata["data-Knowledge Engineering"]) || 0), cdata["data-Knowledge Engineering Notes"] && (update.knowledge_engineering_notes = cdata["data-Knowledge Engineering Notes"]), _.extend(update, calc_npc_skill_display("knowledge_engineering", cdata["data-Knowledge Engineering"] || "", cdata["data-Knowledge Engineering Notes"] || "")), cdata["data-Knowledge Geography"] && (update.knowledge_geography = parseInt(cdata["data-Knowledge Geography"]) || 0), cdata["data-Knowledge Geography Notes"] && (update.knowledge_geography_notes = cdata["data-Knowledge Geography Notes"]), _.extend(update, calc_npc_skill_display("knowledge_geography", cdata["data-Knowledge Geography"] || "", cdata["data-Knowledge Geography Notes"] || "")), cdata["data-Knowledge History"] && (update.knowledge_history = parseInt(cdata["data-Knowledge History"]) || 0), cdata["data-Knowledge History Notes"] && (update.knowledge_history_notes = cdata["data-Knowledge History Notes"]), _.extend(update, calc_npc_skill_display("knowledge_history", cdata["data-Knowledge History"] || "", cdata["data-Knowledge History Notes"] || "")), cdata["data-Knowledge Local"] && (update.knowledge_local = parseInt(cdata["data-Knowledge Local"]) || 0), cdata["data-Knowledge Local Notes"] && (update.knowledge_local_notes = cdata["data-Knowledge Local Notes"]), _.extend(update, calc_npc_skill_display("knowledge_local", cdata["data-Knowledge Local"] || "", cdata["data-Knowledge Local Notes"] || "")), cdata["data-Knowledge Nature"] && (update.knowledge_nature = parseInt(cdata["data-Knowledge Nature"]) || 0), cdata["data-Knowledge Nature Notes"] && (update.knowledge_nature_notes = cdata["data-Knowledge Nature Notes"]), _.extend(update, calc_npc_skill_display("knowledge_nature", cdata["data-Knowledge Nature"] || "", cdata["data-Knowledge Nature Notes"] || "")), cdata["data-Knowledge Nobility"] && (update.knowledge_nobility = parseInt(cdata["data-Knowledge Nobility"]) || 0), cdata["data-Knowledge Nobility Notes"] && (update.knowledge_nobility_notes = cdata["data-Knowledge Nobility Notes"]), _.extend(update, calc_npc_skill_display("knowledge_nobility", cdata["data-Knowledge Nobility"] || "", cdata["data-Knowledge Nobility Notes"] || "")), cdata["data-Knowledge Planes"] && (update.knowledge_planes = parseInt(cdata["data-Knowledge Planes"]) || 0), cdata["data-Knowledge Planes Notes"] && (update.knowledge_planes_notes = cdata["data-Knowledge Planes Notes"]), _.extend(update, calc_npc_skill_display("knowledge_planes", cdata["data-Knowledge Planes"] || "", cdata["data-Knowledge Planes Notes"] || "")), cdata["data-Knowledge Religion"] && (update.knowledge_religion = parseInt(cdata["data-Knowledge Religion"]) || 0), cdata["data-Knowledge Religion Notes"] && (update.knowledge_religion_notes = cdata["data-Knowledge Religion Notes"]), _.extend(update, calc_npc_skill_display("knowledge_religion", cdata["data-Knowledge Religion"] || "", cdata["data-Knowledge Religion Notes"] || "")), cdata["data-Linguistics"] && (update.linguistics = parseInt(cdata["data-Linguistics"]) || 0), cdata["data-Linguistics Notes"] && (update.linguistics_notes = cdata["data-Linguistics Notes"]), _.extend(update, calc_npc_skill_display("linguistics", cdata["data-Linguistics"] || "", cdata["data-Linguistics Notes"] || "")), cdata["data-Perception"] && (update.perception = parseInt(cdata["data-Perception"]) || 0), cdata["data-Perception Notes"] && (update.perception_notes = cdata["data-Perception Notes"]), _.extend(update, calc_npc_skill_display("perception", cdata["data-Perception"] || "", cdata["data-Perception Notes"] || "")), cdata["data-Perform"] && (update.perform = parseInt(cdata["data-Perform"]) || 0), cdata["data-Perform Notes"] && (update.perform_notes = cdata["data-Perform Notes"]), _.extend(update, calc_npc_skill_display("perform", cdata["data-Perform"] || "", cdata["data-Perform Notes"] || "")), cdata["data-Profession"] && (update.profession = parseInt(cdata["data-Profession"]) || 0), cdata["data-Profession Notes"] && (update.profession_notes = cdata["data-Profession Notes"]), _.extend(update, calc_npc_skill_display("profession", cdata["data-Profession"] || "", cdata["data-Profession Notes"] || "")), cdata["data-Ride"] && (update.ride = parseInt(cdata["data-Ride"]) || 0), cdata["data-Ride Notes"] && (update.ride_notes = cdata["data-Ride Notes"]), _.extend(update, calc_npc_skill_display("ride", cdata["data-Ride"] || "", cdata["data-Ride Notes"] || "")), cdata["data-Sense Motive"] && (update.sense_motive = parseInt(cdata["data-Sense Motive"]) || 0), cdata["data-Sense Motive Notes"] && (update.sense_motive_notes = cdata["data-Sense Motive Notes"]), _.extend(update, calc_npc_skill_display("sense_motive", cdata["data-Sense Motive"] || "", cdata["data-Sense Motive Notes"] || "")), cdata["data-Sleight Of Hand"] && (update.sleight_of_hand = parseInt(cdata["data-Sleight Of Hand"]) || 0), cdata["data-Sleight Of Hand Notes"] && (update.sleight_of_hand_notes = cdata["data-Sleight Of Hand Notes"]), _.extend(update, calc_npc_skill_display("sleight_of_hand", cdata["data-Sleight Of Hand"] || "", cdata["data-Sleight Of Hand Notes"] || "")), cdata["data-Spellcraft"] && (update.spellcraft = parseInt(cdata["data-Spellcraft"]) || 0), cdata["data-Spellcraft Notes"] && (update.spellcraft_notes = cdata["data-Spellcraft Notes"]), _.extend(update, calc_npc_skill_display("spellcraft", cdata["data-Spellcraft"] || "", cdata["data-Spellcraft Notes"] || "")), cdata["data-Stealth"] && (update.stealth = parseInt(cdata["data-Stealth"]) || 0), cdata["data-Stealth Notes"] && (update.stealth_notes = cdata["data-Stealth Notes"]), _.extend(update, calc_npc_skill_display("stealth", cdata["data-Stealth"] || "", cdata["data-Stealth Notes"] || "")), cdata["data-Survival"] && (update.survival = parseInt(cdata["data-Survival"]) || 0), cdata["data-Survival Notes"] && (update.survival_notes = cdata["data-Survival Notes"]), _.extend(update, calc_npc_skill_display("survival", cdata["data-Survival"] || "", cdata["data-Survival Notes"] || "")), cdata["data-Swim"] && (update.swim = parseInt(cdata["data-Swim"]) || 0), cdata["data-Swim Notes"] && (update.swim_notes = cdata["data-Swim Notes"]), _.extend(update, calc_npc_skill_display("swim", cdata["data-Swim"] || "", cdata["data-Swim Notes"] || "")), cdata["data-Use Magic Device"] && (update.use_magic_device = parseInt(cdata["data-Use Magic Device"]) || 0), cdata["data-Use Magic Device Notes"] && (update.use_magic_device_notes = cdata["data-Use Magic Device Notes"]), _.extend(update, calc_npc_skill_display("use_magic_device", cdata["data-Use Magic Device"] || "", cdata["data-Use Magic Device Notes"] || "")), cdata["data-Skills Misc"] && (update.skills_notes = cdata["data-Skills Misc"]), cdata["data-Languages"] && (update.languages = cdata["data-Languages"]), cdata["data-SQ"] && (update.sq = cdata["data-SQ"]), cdata["data-Combat Gear"] && (update.combat_gear = cdata["data-Combat Gear"]), cdata["data-Environment"] && (update.environment = cdata["data-Environment"]), cdata["data-Organization"] && (update.organization = cdata["data-Organization"]), cdata["data-Treasure"] && (update.treasure = cdata["data-Treasure"]), cdata["data-Description"] && (update.background = cdata["data-Description"]), cdata["data-Attacks"]) {
                var atkz;
                try { atkz = JSON.parse(cdata["data-Attacks"]) } catch (error) { atkz = [] } atkz.length && _.extend(update, npcdrop_add_attacks(atkz, update))
            } else (cdata.Melee || cdata.Ranged) && (cdata.Melee ? (update.meleeattacks_flag = 1, _.extend(update, npc_attack_parser(cdata.Melee, "melee", update))) : update.meleeattacks_flag = 0, cdata.Ranged ? (update.rangedattacks_flag = 1, _.extend(update, npc_attack_parser(cdata.Ranged, "ranged", update))) : update.rangedattacks_flag = 0);
            if (cdata["data-Special Atk"]) {
                var specz;
                try { specz = JSON.parse(cdata["data-Special Atk"]) } catch (error) { specz = [] } specz.length && _.extend(update, npcdrop_add_special_attacks(specz))
            } else cdata["Special Attacks"] ? (update.specialattacks_flag = 1, update.specialattacks_notes = cdata["Special Attacks"]) : update.specialattacks_flag = 0;
            if (cdata["data-Special abilities"]) {
                var abz;
                try { abz = JSON.parse(cdata["data-Special Abilities"]) } catch (error) { abz = [] } abz.length && _.extend(update, npcdrop_add_specabs(abz))
            } setAttrs(update, { silent: !0 }, () => {
                callback && callback(), update = {};
                var pages = [];
                if (objspells.length && (!0, _.each(objspells, obj => { obj.name && pages.push("Spells:" + toTitleCase(obj.name)) })), objlikes.length && (!0, _.each(objlikes, obj => { obj.Name && obj.Spell && pages.push("Spells:" + toTitleCase(obj.Spell)) })), cdata["data-Feats"]) {
                    var parsed;
                    try { parsed = JSON.parse(cdata["data-Feats"]) } catch (error) { parsed = cdata["data-Feats"].split(",") } objfeats = Array.isArray(parsed) ? parsed : [], _.each(objfeats, obj => {
                        var featname = "";
                        featname = -1 === obj.indexOf("(") ? "Feats:" + obj.trim() : "Feats:" + obj.split("(")[0].trim(), pages.push(featname)
                    })
                } else var objfeats = [];
                getCompendiumPage(pages, compendiumdata => {
                    let cdatarr;
                    "object" == typeof compendiumdata ? cdatarr = Object.values(compendiumdata) : Array.isArray(compendiumdata) ? cdatarr = compendiumdata : (cdatarr = []).push(compendiumdata), objspells.length && (tmpobj = drop_add_spells(objspells, cdatarr, update, !1), _.extend(update, tmpobj)), objlikes.length && (tmpobj = drop_add_spellike(objlikes, cdatarr, update, !1), _.extend(update, tmpobj)), objfeats.length && (tmpobj = drop_add_feats(objfeats, cdatarr, !1), _.extend(update, tmpobj)), setAttrs(update, { silent: !0 }, () => { setAttrs({ "build-flag-npc": 0 }, { silent: !0 }) })
                })
            })
        })
    }, npcdrop_add_attacks = function (objs, values) {
        let update = {}, meleecount = 0, rangedcount = 0;
        return _.each(objs, obj => {
            if (obj.Name) {
                let newrowid = generateRowID(), repsec = "", type = "";
                if (obj.Range ? (rangedcount++, type = "ranged", update[`${repsec = "repeating_npcatk-ranged_"}${newrowid}_atkrange`] = obj.Range) : (meleecount++, repsec = "repeating_npcatk-melee_", type = "melee"), update[`${repsec}${newrowid}_atkname`] = obj.Name, update[`${repsec}${newrowid}_options-flag`] = 0, obj["Attack Bonuses"]) {
                    let atkmodz = obj["Attack Bonuses"].replace(/[^\d\/\-]/gi, "");
                    if (-1 == atkmodz.indexOf("/")) update[`${repsec}${newrowid}_atkmod`] = atkmodz;
                    else {
                        let atks = atkmodz.split("/");
                        update[`${repsec}${newrowid}_multipleatk_flag`] = 1;
                        let i = 1;
                        _.each(atks, atk => { update[`${repsec}${newrowid}_atkmod` + (i > 1 ? i : "")] = atk, i++ })
                    }
                } else update[`${repsec}${newrowid}_atkmod`] = "0";
                obj["Critical Range"] ? update[`${repsec}${newrowid}_atkcritrange`] = parseInt(obj["Critical Range"]) || 20 : update[`${repsec}${newrowid}_atkcritrange`] = 20, obj["Damage 1"] && (update[`${repsec}${newrowid}_dmgflag`] = 1, update[`${repsec}${newrowid}_dmgbase`] = obj["Damage 1"]), obj["Damage 1 Notes or Type"] ? update[`${repsec}${newrowid}_dmgtype`] = obj["Damage 1 Notes or Type"] : update[`${repsec}${newrowid}_dmgtype`] = "", obj["Damage 1 Critical Multiplier"] && (update[`${repsec}${newrowid}_dmgcritmulti`] = parseInt(obj["Damage 1 Critical Multiplier"].toLowerCase().replace(/[^\d]/gi, "")) || 2), obj["Damage 2"] && (update[`${repsec}${newrowid}_dmg2flag`] = 1, update[`${repsec}${newrowid}_dmg2base`] = obj["Damage 2"]), obj["Damage 2 Notes or Type"] ? update[`${repsec}${newrowid}_dmg2type`] = obj["Damage 2 Notes or Type"] : update[`${repsec}${newrowid}_dmg2type`] = "", obj["Damage 2 Critical Multiplier"] && (update[`${repsec}${newrowid}_dmg2critmulti`] = parseInt(obj["Damage 2 Critical Multiplier"].toLowerCase().replace(/[^\d]/gi, "")) || 2), obj.Description && (update[`${repsec}${newrowid}_descflag`] = 1, update[`${repsec}${newrowid}_atkdesc`] = obj.Description);
                let tmpvalues = {};
                _.extend(tmpvalues, values, update), tmpvalues.npc = "1", _.extend(update, calc_npc_attack(type, newrowid, tmpvalues))
            }
        }), _.isEmpty(update) ? (update.meleeattacks_flag = 0, update.rangedattacks_flag = 0) : (update.meleeattacks_flag = meleecount > 0 ? 1 : 0, update.rangedattacks_flag = rangedcount > 0 ? 1 : 0), update
    }, npc_attack_parser = function (source, type, values) {
        let repsec = "repeating_npcatk-melee_";
        "ranged" == type && (repsec = "repeating_npcatk-ranged_");
        let update = {}, strz = source.replace(/\)\s+(or|Or|OR|and|And|AND)\s+/g, "), ").split(",").map(x => x.trim()), newrowid = "";
        return _.each(strz, str => {
            newrowid = generateRowID();
            let atkstr = (str.split("(")[0] || "").trim(), dmgstr = (str.split("(")[1] || "").trim().replace(/\)$/, "").trim();
            update[`${repsec}${newrowid}_atkname`] = "Unknown", update[`${repsec}${newrowid}_atkmod`] = "0", update[`${repsec}${newrowid}_dmgtype`] = " ", update[`${repsec}${newrowid}_atkcritrange`] = 20, update[`${repsec}${newrowid}_dmgcritmulti`] = 2, update[`${repsec}${newrowid}_dmgbase`] = "", update[`${repsec}${newrowid}_atkdesc`] = "";
            let i = 0;
            _.each(atkstr.match(/(^|\+|\-)[^\+\-]+(?=(\-|\+)|$)/g), atk => {
                if (atk) {
                    if (update[repsec + newrowid + (i > 0 ? "_atkmod" : "_atkname") + (i > 1 ? i : "")] = i > 0 ? atk.replace(/[^\d\-]/gi, "") : atk.trim(), i > 0 && atk.trim().split(" ").length > 1) {
                        let tmparr = atk.trim().split(" ");

                        for (let i = 1;
                            i < tmparr.length;
                            i++)update[`${repsec}${newrowid}_atkdesc`] += " " + tmparr[i]
                    } i++
                }
            }), update[`${repsec}${newrowid}_multipleatk_flag`] = i > 2 ? 1 : 0;
            let dmgparts = dmgstr.split("/");
            dmgparts.length && (update[`${repsec}${newrowid}_dmgflag`] = 1, _.each(dmgparts, part => {
                part && ((part = part.trim()).match(/^\d\d20/g) ? (update[`${repsec}${newrowid}_atkcritrange`] = part.substring(0, 2), update[`${repsec}${newrowid}_dmgtype`] += " " + part.replace(part.match(/^\d\d20/g)[0], "").replace(/^\s*\;/, "").trim()) : part.match(/\d+\-20/g) ? (update[`${repsec}${newrowid}_atkcritrange`] = part.match(/\d+\-20/g)[0].match(/\d+/g)[0], update[`${repsec}${newrowid}_dmgtype`] += " " + part.replace(part.match(/\d+\-20/g)[0], "").replace(/^\s*\;/, "").trim()) : part.match(/[x×]\d+/g) ? (update[`${repsec}${newrowid}_dmgcritmulti`] = part.match(/[x×]\d+/g)[0].match(/\d+/g)[0], update[`${repsec}${newrowid}_dmgtype`] += " " + part.replace(part.match(/[x×]\d+/g)[0], "").replace(/^\s*\;
                "").trim()) : part.match(/\d+d*\d*\+*\-*\d*/g) ? (update[`${repsec}${newrowid}_dmgbase`] = part.match(/\d+d*\d*\+*\-*\d*/g)[0], update[`${repsec}${newrowid}_dmgtype`] += " " + part.replace(update[`${repsec}${newrowid}_dmgbase`], "").replace(/^\s*\;/, "").trim()) : (update[`${repsec}${newrowid}_dmgtype`] += " " + part.replace(/^\s*\;/, "").trim(), update[`${repsec}${newrowid}_dmgbase`] = "0"))
    }), update[`${repsec}${newrowid}_dmgtype`] = update[`${repsec}${newrowid}_dmgtype`].trim()), update[`${repsec}${newrowid}_options-flag`] = 0, update[`${repsec}${newrowid}_atkdesc`] = update[`${repsec}${newrowid}_atkdesc`].trim(), update[`${repsec}${newrowid}_atkdesc`].length && (update[`${repsec}${newrowid}_descflag`] = "{{descflag=[[1]]}}{{desc=@{atkdesc}}}");
    let tmpvalues = {};
    _.extend(tmpvalues, values, update), tmpvalues.npc = "1", _.extend(update, calc_npc_attack(type, newrowid, tmpvalues))
}), update }, npcdrop_add_special_attacks = function (objs) {
    var update = {}, repsec = "repeating_npcatk-special_";
    return _.each(objs, obj => {
        var newrowid = generateRowID();
        obj.Name && (update[`${repsec}${newrowid}_atkname`] = obj.Name, update[`${repsec}${newrowid}_options-flag`] = 0), obj["Per Day"] && (update[`${repsec}${newrowid}_perday_max`] = parseInt(obj["Per Day"]) || 1), obj["Attack Bonus"] ? (update[`${repsec}${newrowid}_atkflag`] = "{{attack=1}}{{roll=[[1d20cs>@{atkcritrange}+@{atkmod}[MOD]+@{rollmod_attack}[QUERY]]]}}{{critconfirm=[[1d20cs20+@{atkmod}[MOD]+@{rollmod_attack}[QUERY]]]}}", update[`${repsec}${newrowid}_atkmod`] = obj["Attack Bonus"].replace(/[^\d\-]/gi, "")) : update[`${repsec}${newrowid}_atkflag`] = "0", obj["Critical Range"] ? update[`${repsec}${newrowid}_atkcritrange`] = parseInt(obj["Critical Range"].replace(/[^\d]/gi, "")) || 20 : update[`${repsec}${newrowid}_atkcritrange`] = 20, obj.Range && (update[`${repsec}${newrowid}_rangeflag`] = "{{range=@{atkrange}}}", update[`${repsec}${newrowid}_atkrange`] = obj.Range), obj.Area && (update[`${repsec}${newrowid}_areaflag`] = "{{area=@{atkarea}}}", update[`${repsec}${newrowid}_atkarea`] = obj.Area), obj.Effect && (update[`${repsec}${newrowid}_effectflag`] = "{{effect=@{atkeffect}}}", update[`${repsec}${newrowid}_atkeffect`] = obj.Effect), obj["Saving Throw"] ? (update[`${repsec}${newrowid}_atksave`] = obj["Saving Throw"], "none" == obj["Saving Throw"].toLowerCase().trim() ? update[`${repsec}${newrowid}_atksaveflag`] = "0" : update[`${repsec}${newrowid}_atksaveflag`] = "{{save=1}}{{savedc=@{atkdc}}}{{saveeffect=@{atksave}}}") : update[`${repsec}${newrowid}_atksave`] = " ", obj["Saving Throw DC"] && (update[`${repsec}${newrowid}_atksaveflag`] || (update[`${repsec}${newrowid}_atksaveflag`] = "{{save=1}}{{savedc=@{atkdc}}}{{saveeffect=@{atksave}}}"), update[`${repsec}${newrowid}_atkdc`] = parseInt(obj["Saving Throw DC"].replace(/[^\d\-]/gi, "")) || 0), obj["Damage 1"] && (update[`${repsec}${newrowid}_dmgflag`] = "{{damage=1}}{{dmg1flag=1}}{{dmg1=[[@{dmgbase}[MOD]+@{rollmod_damage}[QUERY]]]}}{{dmg1type=@{dmgtype}}}{{dmg1crit=[[(@{dmgbase}[MOD]+@{rollmod_damage}[QUERY])*@{dmgcritmulti}]]}}", update[`${repsec}${newrowid}_dmgbase`] = obj["Damage 1"]), obj["Damage 1 Notes or Type"] && (update[`${repsec}${newrowid}_dmgtype`] = obj["Damage 1 Notes or Type"]), obj["Damage 1 Critical Multiplier"] && (update[`${repsec}${newrowid}_dmgcritmulti`] = parseInt(obj["Damage 1 Critical Multiplier"].toLowerCase().replace("x", "")) || 2), obj["Damage 2"] && (update[`${repsec}${newrowid}_dmg2flag`] = "{{damage=1}} {{dmg2flag=1}}{{dmg2=[[@{dmg2base}[MOD]+@{rollmod_damage}[QUERY]]]}}{{dmg2type=@{dmg2type}}}{{dmg2crit=[[(@{dmg2base}[MOD]+@{rollmod_damage}[QUERY])*@{dmg2critmulti}]]}}", update[`${repsec}${newrowid}_dmg2base`] = obj["Damage 2"]), obj["Damage 2 Notes or Type"] && (update[`${repsec}${newrowid}_dmg2type`] = obj["Damage 2 Notes or Type"]), obj["Damage 2 Critical Multiplier"] && (update[`${repsec}${newrowid}_dmg2critmulti`] = parseInt(obj["Damage 2 Critical Multiplier"].toLowerCase().replace("x", "")) || 2), obj.Description && (update[`${repsec}${newrowid}_descflag`] = "{{descflag=[[1]]}}{{desc=@{atkdesc}}}",
            update[`${repsec}${newrowid}_atkdesc`] = obj.Description)
    }), _.isEmpty(update) ? update.specialattacks_flag = 0 : update.specialattacks_flag = 1, update
}, npcdrop_add_specabs = function (objs) {
    var update = {}, repsec = "repeating_abilities_";
    return _.each(objs, obj => {
        var newrowid = generateRowID();
        obj.Name && (update[`${repsec}${newrowid}_name`] = obj.Name, update[`${repsec}${newrowid}_options-flag`] = 0, update[`${repsec}${newrowid}_fromcompendium`] = obj.Name), obj.Type && (update[`${repsec}${newrowid}_type`] = obj.Type), obj.Description && (update[`${repsec}${newrowid}_descflag`] = "{{descflag=[[1]]}}{{desc=@{description}}}", update[`${repsec}${newrowid}_description`] = obj.Description)
    }), _.isEmpty(update) ? update.special_abilities_flag = 0 : update.special_abilities_flag = 1, update
}, calc_npc_skill_display = function (skill, value, note) {
    var update = {}, display = "", flag = 0, intval = parseInt(value) || 0;
    return 0 != intval && (display += intval >= 0 ? "+" + intval : "" + intval, flag = 1), note && note.length > 0 && (0 === display.length && (display += "+0"), display += " (" + note + ")", flag = 1), update[skill + "_display"] = display, update[skill + "_flag"] = flag, update
}, update_default_token = function () {
    getAttrs(["hp_max", "ac", "size", "cd_bar1_v", "cd_bar1_m", "cd_bar1_l", "cd_bar2_v", "cd_bar2_m", "cd_bar2_l", "cd_bar3_v", "cd_bar3_m", "cd_bar3_l"], v => {
        var default_attr = { width: 70, height: 70 };
        if (v.size) {
            var squares = 1, obj_size = pfoglobals_size.find(size_item => size_item.size === v.size);
            _.isEmpty(obj_size) || (squares = Math.max(parseFloat(obj_size.squares) || 1, 1));
            let squaresize = parseInt(70 * squares);
            default_attr.width = squaresize, default_attr.height = squaresize
        } var getList = {};
        for (x = 1;
            x <= 3;
            x++)_.each(["v", "m"], letter => {
                var keyname = "cd_bar" + x + "_" + letter;
                v[keyname] && (getList[keyname] = v[keyname])
            });
        getAttrs(_.values(getList), values => { _.each(_.keys(getList), keyname => { v[keyname] = void 0 == values[getList[keyname]] ? "" : values[getList[keyname]] }), v.cd_bar1_l ? default_attr.bar1_link = v.cd_bar1_l : v.cd_bar1_v || v.cd_bar1_m ? (v.cd_bar1_v && (default_attr.bar1_value = v.cd_bar1_v), v.cd_bar1_m && (default_attr.bar1_max = v.cd_bar1_m)) : (default_attr.bar1_value = v.hp_max, default_attr.bar1_max = v.hp_max), v.cd_bar2_l ? default_attr.bar2_link = v.cd_bar2_l : v.cd_bar2_v || v.cd_bar2_m ? (v.cd_bar2_v && (default_attr.bar2_value = v.cd_bar2_v), v.cd_bar2_m && (default_attr.bar2_max = v.cd_bar2_m)) : default_attr.bar2_link = "ac", v.cd_bar3_l ? default_attr.bar3_link = v.cd_bar3_l : (v.cd_bar3_v || v.cd_bar3_m) && (v.cd_bar3_v && (default_attr.bar3_value = v.cd_bar3_v), v.cd_bar3_m && (default_attr.bar3_max = v.cd_bar3_m)), setDefaultToken(default_attr) })
    })
}, pc_drop_handler = function (cdata, v) {
    getAttrs(["pcdrop_name", "pcdrop_uniq", "pcdrop_category", "pcdrop_content", "size", "caster1_flag", "caster2_flag", "class1_name", "class2_name"],
        v => {
            "Name" in cdata || (cdata.Name = v.pcdrop_name || ""), "uniqueName" in cdata || (cdata.uniqueName = v.pcdrop_uniq || ""), "Category" in cdata || (cdata.Category = v.pcdrop_category || ""), "Content" in cdata || (cdata.Content = v.pcdrop_content || "");
            let objs = [], page = {}, pages = [], update = {}, callbacks = [];
            switch (update.pcdrop_name = "", update.pcdrop_uniq = "", update.pcdrop_category = "", update.pcdrop_data = "", update.pcdrop_content = "", (cdata.Category || "").toLowerCase()) {
                case "spells": if ("1" == (v.caster1_flag || "0") || "1" == (v.caster2_flag || "0")) {
                    let level, caster = "0", nb = 0, i = 0, j = 0, cl1arr = (v.class1_name || "unkownclass").trim().toLowerCase().replace(/\s+/, " ").split(" "), cl2arr = (v.class2_name || "unkownclass").trim().toLowerCase().replace(/\s+/, " ").split(" ");
                    _.each((cdata.Level || "").toLowerCase().replace(/\//g, " ").split(","), lvl => {
                        let lvlarr = lvl.trim().replace(/\s+/, " ").split(" ");
                        for (j = 0;
                            j < lvlarr.length;
                            j++) {
                                for (i = 0;
                                    i < cl1arr.length;
                                    i++)cl1arr[i] == lvlarr[j] && ("0" == caster && (caster = "1", level = lvl.replace(/[^\d]+/g, "") || "0"), nb++);
                            for (i = 0;
                                i < cl2arr.length;
                                i++)cl2arr[i] == lvlarr[j] && ("0" == caster && (caster = "2", level = lvl.replace(/[^\d]+/g, "") || "0"), nb++)
                        }
                    }), "0" == caster || nb > 1 ? startCharactermancer("spell-choose") : pc_drop_spell(level, caster)
                } break;
                case "feats": objs.push(v.pcdrop_name || ""), page.name = v.pcdrop_name || "", page.id = v.pcdrop_uniq || "", page.data = cdata, pages.push(page), _.extend(update, drop_add_feats(objs, pages, !0)), setAttrs(update, { silent: !0 });
                    break;
                case "items": _.extend(update, drop_add_item(cdata, v)), callbacks.push(function () { update_gear_weight_total() }), "Weapon Category" in cdata && _.extend(update, drop_add_attack(cdata, v)), "Armor Category" in cdata && (_.extend(update, drop_add_armor(cdata, v)), callbacks.push(function () { update_ac_items() })), setAttrs(update, { silent: !0 }, () => { callbacks.length && _.each(callbacks, callback => { callback() }) })
            }
        })
}, pc_drop_spell = function (level = "0", caster = "1") {
    let fields = [];
    fields = ["pcdrop_name", "pcdrop_uniq", "pcdrop_category", "pcdrop_data", "pcdrop_content", "caster1_flag", "caster2_flag", "npc"].concat(pfoglobals_spell_fields, pfoglobals_babs_fields, pfoglobals_abilities), getAttrs(fields, v => {
        let spellid, update = {}, objs = [], obj = {}, pages = [], page = {}, tmpupd = {};
        page.name = v.pcdrop_name, page.id = v.pcdrop_uniq, page.data = JSON.parse(v.pcdrop_data), page.content = v.pcdrop_content || "", pages.push(page), update.pcdrop_name = "", update.pcdrop_uniq = "", update.pcdrop_category = "", update.pcdrop_data = "", update.pcdrop_content = "", "like" == level ? (obj.Name = v.pcdrop_name, obj.Frequency = "At Will", obj["Spell-source"] = v.pcdrop_name, objs.push(obj), tmpupd = pfom.drop_add_spellike(objs, pages, v, !0), spellid = Object.keys(tmpupd)[0].substring(21, 41)) : (obj.name = v.pcdrop_name, obj.level = level, obj.spellcaster = caster, objs.push(obj), tmpupd = pfom.drop_add_spells(objs, pages, v, !0), spellid = Object.keys(tmpupd)[0].substring(18, 38)), _.extend(update, tmpupd), setAttrs(update, { silent: !0 }, () => { pfom.update_spells(level, spellid) })
    })
}, drop_add_feats = function (objs, cdatarr, isPc = !1) {
    let update = {};
    return _.each(objs, obj => {
        let featObj = {}, newrowid = generateRowID(), featname = "", featname2 = "", featRepsec = "repeating_feats";
        if (featname = obj.trim().replace("Feats:", "").trim(), -1 != obj.indexOf("(") && (featname2 = obj.split("(")[0].trim().replace("Feats:", "").trim()), featObj[`_${newrowid}_name`] = featname, featObj[`_${newrowid}_options-flag`] = 0, featObj[`_${newrowid}_type`] = "misc", !_.isEmpty(cdatarr)) {
            let cdata = cdatarr.find(o => o.data && o.data["Feat Name"] && o.data["Feat Name"].toLowerCase().trim() === featname.toLowerCase() && "Feats" === o.data.Category);
            if (cdata && cdata.id && cdata.data || !featname2.length || (cdata = cdatarr.find(o => o.data && o.data["Feat Name"] && o.data["Feat Name"].toLowerCase().trim() === featname2.toLowerCase() && "Feats" === o.data.Category)), cdata && cdata.id && cdata.data) {
                if (cdata.data["Feat Name"] && (featObj[`_${newrowid}_fromcompendium`] = "Feats:" + cdata.name), cdata.data["Feat Type"]) {
                    let featType = cdata.data["Feat Type"].toLowerCase().trim();
                    ["general", "combat", "critical", "grit", "item creation", "metamagic", "monster", "panache", "performance", "style", "teamwork"].includes(featType) ? (featObj[`_${newrowid}_type`] = featType, "metamagic" == featType && isPc && (featRepsec = "repeating_metamagic")) : featObj[`_${newrowid}_type`] = "misc"
                } cdata.data.Prerequisites && (featObj[`_${newrowid}_prerequisites`] = cdata.data.Prerequisites), cdata.data.Benefit && (featObj[`_${newrowid}_benefits`] = cdata.data.Benefit), cdata.data.Normal && (featObj[`_${newrowid}_normal`] = cdata.data.Normal), cdata.data["data-description"] ? featObj[`_${newrowid}_description`] = cdata.data["data-description"] : cdata.content && (featObj[`_${newrowid}_description`] = cdata.content)
            }
        } _.each(Object.keys(featObj), key => { update[featRepsec + key] = featObj[key] })
    }), update
}, drop_add_spells = function (objs, cdatarr, values, isPc = !1) {
    let update = {};
    return _.each(objs, obj => {
        if (obj.name) {
            let newrowid = generateRowID(), level = 0;
            obj.level && (level = parseInt(obj.level) || 0);
            let repsec = `repeating_spell-${level}_`;
            if (update[`${repsec}${newrowid}_spellname`] = toTitleCase(obj.name.replace("Spells:", "")), obj.domain && (isPc ? update[`${repsec}${newrowid}_spelldomaineflag`] = 1 : update[`${repsec}${newrowid}_spellname`] += " (D)"), update[`${repsec}${newrowid}_options-flag`] = 0, obj.spellcaster ? update[`${repsec}${newrowid}_spellcaster`] = obj.spellcaster : update[`${repsec}${newrowid}_spellcaster`] = 1, !_.isEmpty(cdatarr)) {
                let cdata = cdatarr.find(o => o.name && o.name.toLowerCase().trim() === obj.name.replace("Spells:", "").toLowerCase().trim() && "Spells" === o.data.Category);
                cdata && cdata.id && cdata.data && (update[`${repsec}${newrowid}_fromcompendium`] = "Spells:" + cdata.name, cdata.data.School && (update[`${repsec}${newrowid}_spellschool`] = cdata.data.School), cdata.data.Level && (update[`${repsec}${newrowid}_spellclasslevel`] = cdata.data.Level), cdata.data["Casting Time"] && (update[`${repsec}${newrowid}_spellcastingtime`] = cdata.data["Casting Time"]), cdata.data.Components && (update[`${repsec}${newrowid}_spellcomponent`] = cdata.data.Components), cdata.data.Range && (update[`${repsec}${newrowid}_spellrange`] = cdata.data.Range), cdata.data.Area && (update[`${repsec}${newrowid}_spellarea`] = cdata.data.Area), cdata.data.Target && (update[`${repsec}${newrowid}_spelltargets`] = cdata.data.Target), cdata.data.Effect && (update[`${repsec}${newrowid}_spelleffect`] = cdata.data.Effect), cdata.data.Duration && (update[`${repsec}${newrowid}_spellduration`] = cdata.data.Duration), cdata.data["Saving Throw"] ? (update[`${repsec}${newrowid}_spellsave`] = cdata.data["Saving Throw"], "none" == cdata.data["Saving Throw"].toLowerCase().trim() ? update[`${repsec}${newrowid}_spellsaveflag`] = 0 : update[`${repsec}${newrowid}_spellsaveflag`] = "{{save=1}}") : update[`${repsec}${newrowid}_spellsave`] = " ", obj.dc && (update[`${repsec}${newrowid}_spellsaveflag`] || (update[`${repsec}${newrowid}_spellsaveflag`] = "{{save=1}}"), update[`${repsec}${newrowid}_spelldc_mod`] = parseInt(String(obj.dc).replace(/[^\d]/gi, "")) || 0), cdata.data["Spell Resistance"] && (update[`${repsec}${newrowid}_spellresistance`] = cdata.data["Spell Resistance"], "no" == cdata.data["Spell Resistance"].toLowerCase().trim() ? update[`${repsec}${newrowid}_spellresistanceflag`] = "0" : update[`${repsec}${newrowid}_spellresistanceflag`] = "{{sr=1}}"), cdata.data["Spell Attack"] && (update[`${repsec}${newrowid}_spellatkflag`] = "{{attack=1}}", -1 != cdata.data["Spell Attack"].toLowerCase().indexOf("ranged touch") ? update[`${repsec}${newrowid}_spellatktype`] = "ranged" : -1 != cdata.data["Spell Attack"].toLowerCase().indexOf("touch") && (update[`${repsec}${newrowid}_spellatktype`] = "melee")), cdata.data["Spell Damage"] && (update[`${repsec}${newrowid}_spelldmgflag`] = "{{damage=1}} {{dmg1flag=1}}", update[`${repsec}${newrowid}_spelldmg`] = parse_compendium_formula(cdata.data["Spell Damage"] || "", obj.spellcaster || "1", !1)), cdata.data["Spell Damage Type"] && (update[`${repsec}${newrowid}_spelldmgtype`] = cdata.data["Spell Damage Type"]), cdata.data["Secondary Spell Damage"] && (update[`${repsec}${newrowid}_spelldmg2flag`] = "{{damage=1}} {{dmg2flag=1}}", update[`${repsec}${newrowid}_spelldmg2`] = cdata.data["Secondary Spell Damage"]), cdata.data["Secondary Spell Damage Type"] && (update[`${repsec}${newrowid}_spelldmg2type`] = cdata.data["Secondary Spell Damage Type"]), cdata.content && (update[`${repsec}${newrowid}_spelldesc`] = parse_compendium_formula(cdata.content || "", obj.spellcaster || "1", !0), update[`${repsec}${newrowid}_spelldescflag`] = "{{descflag=[[1]]}}"))
            } let tmpvalues = {};
            _.extend(tmpvalues, values, update), isPc || (tmpvalues.npc = "1"), _.extend(update, calc_spell(level, newrowid, tmpvalues))
        }
    }), update
}, drop_add_spellike = function (objs, cdatarr, values, isPc = !1) {
    let update = {}, repsec = "repeating_spell-like_";
    return _.each(objs, obj => {
        if (obj.Name) {
            let newrowid = generateRowID();
            if (update[`${repsec}${newrowid}_spellname`] = obj.Name, update[`${repsec}${newrowid}_options-flag`] = 0, isPc) if (obj["Per-day"]) {
                update[`${repsec}${newrowid}_timesperday`] = "per-day";
                let perday = 0;
                (perday = -1 == obj["Per-day"].indexOf("+") ? parseInt(obj["Per-day"]) || 1 : (parseInt(obj["Per-day"].split("+")[0].replace(/[^\d]/gi, "").trim()) || 1) + (parseInt(values[obj["Per-day"].split("+")[1].replace("modifier", "").trim().toLowerCase() + "_mod"]) || 0)) > 0 && (update[`${repsec}${newrowid}_perday`] = 0, update[`${repsec}${newrowid}_perday_max`] = perday, update[`${repsec}${newrowid}_perday_qty`] = perday)
            } else update[`${repsec}${newrowid}_timesperday`] = "at-will";
            else obj.Frequency && ("constant" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "constant" : "at will" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "at-will" : "per hour" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "per-hour" : "per day" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "per-day" : "per week" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "per-week" : "per month" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "per-month" : "per year" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "per-year" : "every x hours" == obj.Frequency.toLowerCase().trim() ? update[`${repsec}${newrowid}_timesperday`] = "every-hours" : update[`${repsec}${newrowid}_timesperday`] = "at-will", (obj.Occurences || obj.Occurrences) && (update[`${repsec}${newrowid}_perday_max`] = parseInt(obj.Occurrences) || parseInt(obj.Occurences) || 0, update[`${repsec}${newrowid}_perday_qty`] = update[`${repsec}${newrowid}_perday_max`]));
            if ((obj.Spell || obj["Spell-source"]) && !_.isEmpty(cdatarr)) {
                let zespell = "";
                zespell = isPc ? obj["Spell-source"] : obj.Spell;
                var cdata = cdatarr.find(o => o.name && o.name.toLowerCase().trim() === zespell.toLowerCase().trim() && "Spells" === o.data.Category);
                cdata && cdata.id && cdata.data && (update[`${repsec}${newrowid}_fromcompendium`] = `Spells:${cdata.name}`, obj.School ? update[`${repsec}${newrowid}_spellschool`] = obj.School : cdata.data.School && (update[`${repsec}${newrowid}_spellschool`] = cdata.data.School), obj.Level ? update[`${repsec}${newrowid}_spellclasslevel`] = obj.Level : cdata.data.Level && (update[`${repsec}${newrowid}_spellclasslevel`] = cdata.data.Level), obj["Casting Time"] ? update[`${repsec}${newrowid}_spellcastingtime`] = obj["Casting Time"] : cdata.data["Casting Time"] && (update[`${repsec}${newrowid}_spellcastingtime`] = cdata.data["Casting Time"]), obj.Range ? update[`${repsec}${newrowid}_spellrange`] = obj.Range : cdata.data.Range && (update[`${repsec}${newrowid}_spellrange`] = cdata.data.Range), obj.Area ? update[`${repsec}${newrowid}_spellarea`] = obj.Area : cdata.data.Area && (update[`${repsec}${newrowid}_spellarea`] = cdata.data.Area), obj.Target ? update[`${repsec}${newrowid}_spelltargets`] = obj.Target : cdata.data.Target && (update[`${repsec}${newrowid}_spelltargets`] = cdata.data.Target), obj.Effect ? update[`${repsec}${newrowid}_spelleffect`] = obj.Effect : cdata.data.Effect && (update[`${repsec}${newrowid}_spelleffect`] = cdata.data.Effect), obj.Duration ? update[`${repsec}${newrowid}_spellduration`] = obj.Duration : cdata.data.Duration && (update[`${repsec}${newrowid}_spellduration`] = cdata.data.Duration), obj["Saving Throw"] ? update[`${repsec}${newrowid}_spellsave`] = obj["Saving Throw"] : cdata.data["Saving Throw"] ? update[`${repsec}${newrowid}_spellsave`] = cdata.data["Saving Throw"] : update[`${repsec}${newrowid}_spellsave`] = " ", update[`${repsec}${newrowid}_spellsave`] && (update[`${repsec}${newrowid}_spellsaveflag`] = "none" == update[`${repsec}${newrowid}_spellsave`].toLowerCase().trim() ? "0" : "{{save=1}}"), obj.DC && (update[`${repsec}${newrowid}_spellsaveflag`] || (update[`${repsec}${newrowid}_spellsaveflag`] = "{{save=1}}"), update[`${repsec}${newrowid}_spelldc_mod`] = parseInt(obj.DC.replace(/[^\d]/gi, "")) || 0), obj["Spell Resistance"] ? update[`${repsec}${newrowid}_spellresistance`] = obj["Spell Resistance"] : cdata.data["Spell Resistance"] && (update[`${repsec}${newrowid}_spellresistance`] = cdata.data["Spell Resistance"]), update[`${repsec}${newrowid}_spellresistance`] && (update[`${repsec}${newrowid}_spellresistanceflag`] = "no" == update[`${repsec}${newrowid}_spellresistance`].toLowerCase().trim() ? "0" : "{{sr=1}}"), obj["Spell Attack"] ? (update[`${repsec}${newrowid}_spellatkmod`] = obj["Spell Attack"], update[`${repsec}${newrowid}_spellatkflag`] = "{{attack=1}}") : cdata.data["Spell Attack"] && (update[`${repsec}${newrowid}_spellatkflag`] = "{{attack=1}}"), obj["Spell Damage"] ? update[`${repsec}${newrowid}_spelldmg`] = obj["Spell Damage"] : cdata.data["Spell Damage"] && (update[`${repsec}${newrowid}_spelldmg`] = parse_compendium_formula(cdata.data["Spell Damage"] || "", obj.spellcaster || "1", !1)), update[`${repsec}${newrowid}_spelldmg`] && (update[`${repsec}${newrowid}_spelldmgflag`] = "{{damage=1}} {{dmg1flag=1}}"), obj["Spell Damage Type"] ? update[`${repsec}${newrowid}_spelldmgtype`] = obj["Spell Damage Type"] : cdata.data["Spell Damage Type"] && (update[`${repsec}${newrowid}_spelldmgtype`] = cdata.data["Spell Damage Type"]), obj["Secondary Spell Damage"] ? update[`${repsec}${newrowid}_spelldmg2`] = obj["Secondary Spell Damage"] : cdata.data["Secondary Spell Damage"] && (update[`${repsec}${newrowid}_spelldmg2`] = cdata.data["Secondary Spell Damage"]), update[`${repsec}${newrowid}_spelldmg2`] && (update[`${repsec}${newrowid}_spelldmg2flag`] = "{{damage=1}} {{dmg2flag=1}}"), obj["Secondary Spell Damage Type"] ? update[`${repsec}${newrowid}_spelldmg2type`] = obj["Secondary Spell Damage Type"] : cdata.data["Secondary Spell Damage Type"] && (update[`${repsec}${newrowid}_spelldmg2type`] = cdata.data["Secondary Spell Damage Type"]), obj.content ? update[`${repsec}${newrowid}_spelldesc`] = parse_compendium_formula(obj.content || "", obj.spellcaster || "1", !0) : cdata.content && (update[`${repsec}${newrowid}_spelldesc`] = parse_compendium_formula(cdata.content || "", obj.spellcaster || "1", !0)), update[`${repsec}${newrowid}_spelldesc`] && (update[`${repsec}${newrowid}_spelldescflag`] = "{{descflag=[[1]]}}"))
            } if (isPc) {
                if (obj.Type && (update[`${repsec}${newrowid}_spelltype`] = obj.Type), obj["Casting-time"] && (update[`${repsec}${newrowid}_spellcastingtime`] = obj["Casting-time"]), obj.Range && (update[`${repsec}${newrowid}_spellrange`] = obj.Range), obj.Area && (update[`${repsec}${newrowid}_spellarea`] = obj.Area), obj.Target && (update[`${repsec}${newrowid}_spelltargets`] = obj.Target), obj.Effect && (update[`${repsec}${newrowid}_spelleffect`] = obj.Effect), obj.Duration && (update[`${repsec}${newrowid}_spellduration`] = obj.Duration), obj["Save-DC"]) {
                    let zedc = 0;
                    -1 == obj["Save-DC"].indexOf("+") ? zedc = parseInt(obj["Save-DC"].replace(/[^\d]/gi, "")) || 0 : _.each(obj["Save-DC"].split("+"), elm => { -1 != elm.toLowerCase().indexOf("modifier") ? zedc += parseInt(values[elm.replace("modifier", "").trim().toLowerCase() + "_mod"]) || 0 : -1 != elm.toLowerCase().indexOf("level") ? -1 == elm.toLowerCase().indexOf("1/2") && (zedc += parseInt(values.level) || 0) : zedc += parseInt(elm.replace(/[^\d]/gi, "").trim()) || 0 }), zedc > 0 && (update[`${repsec}${newrowid}_spellsaveflag`] = "{{save=1}}", update[`${repsec}${newrowid}_spelldc`] = zedc)
                } obj.Attack && (update[`${repsec}${newrowid}_spellatkflag`] = "{{attack=1}}", -1 != obj.Attack.toLowerCase().indexOf("melee") ? update[`${repsec}${newrowid}_spellatkmod`] = "@{melee_mod}[" + obj.Attack + "]" : -1 != obj.Attack.toLowerCase().indexOf("ranged") ? update[`${repsec}${newrowid}_spellatkmod`] = "@{ranged_mod}[" + obj.Attack + "]" : update[`${repsec}${newrowid}_spellatkmod`] = obj.Attack), obj.Damage && (update[`${repsec}${newrowid}_spelldmgflag`] = "{{damage=1}} {{dmg1flag=1}}", -1 == obj.Damage.indexOf("+") ? update[`${repsec}${newrowid}_spelldmg`] = obj.Damage : (update[`${repsec}${newrowid}_spelldmg`] = obj.Damage.split("+")[0], -1 != obj.Damage.split("+")[1].toLowerCase().indexOf("for every two") ? update[`${repsec}${newrowid}_spelldmg`] += "+[[floor(@{caster1_level}/2)]]" : update[`${repsec}${newrowid}_spelldmg`] += obj.Damage.split("+")[1].replace(/[^\d\-\+\s]/gi, "").trim())), obj["Damage-type"] && (update[`${repsec}${newrowid}_spelldmgtype`] = obj["Damage-type"]), obj.Description && (update[`${repsec}${newrowid}_spelldescflag`] = "{{descflag=[[1]]}}", update[`${repsec}${newrowid}_spelldesc`] = obj.Description)
            } var tmpvalues = {};
            _.extend(tmpvalues, update, values), isPc || (tmpvalues.npc = "1"), _.extend(update, calc_spell("like", newrowid, tmpvalues))
        }
    }), update
}, drop_add_item = function (cdata, v) {
    let update = {}, repsec = `repeating_gear_${generateRowID()}_`;
    return update[`${repsec}fromcompendium`] = cdata.uniqueName, update[`${repsec}name`] = cdata.Name, update[`${repsec}cost`] = cdata.Cost || "", update[`${repsec}special`] = cdata.Special || "", update[`${repsec}slot`] = "none" == (cdata.Slot || "none").toLowerCase() ? "" : cdata.Slot || "", update[`${repsec}quantity`] = 1, update[`${repsec}weight`] = parseInt((cdata.Weight || "0").replace(/\D+/g, "")), update[`${repsec}weight_total`] = update[`${repsec}weight`], update[`${repsec}notes`] = parse_compendium_formula(cdata.Content || "", "1", !0), update
}, drop_add_armor = function (cdata, v) {
    let update = {}, repsec = `repeating_acitems_${generateRowID()}_`;
    return update[`${repsec}fromcompendium`] = cdata.uniqueName, update[`${repsec}name`] = cdata.Name, update[`${repsec}ac_bonus`] = parseInt(cdata["Armor/Shield Bonus"]) || 0, update[`${repsec}check_penalty`] = parseInt(cdata["Armor Check Penalty"]) || 0, update[`${repsec}max_dex_bonus`] = cdata["Maximum Dex Bonus"] || "-", update[`${repsec}spell_failure`] = parseInt(cdata["Arcane Spell Failure Chance"]) || 0, update[`${repsec}speed20`] = cdata["Speed 20ft."] || "", update[`${repsec}speed30`] = cdata["Speed 30ft."] || "", (cdata["Armor Category"] || "").toLowerCase().includes("shield") ? (update[`${repsec}type`] = "shield", update[`${repsec}run_factor`] = 4) : (cdata["Armor Category"] || "").toLowerCase().includes("light") ? (update[`${repsec}type`] = "light", update[`${repsec}run_factor`] = 4) : (cdata["Armor Category"] || "").toLowerCase().includes("medium") ? (update[`${repsec}type`] = "medium", update[`${repsec}run_factor`] = 4) : (cdata["Armor Category"] || "").toLowerCase().includes("heavy") && (update[`${repsec}type`] = "heavy", update[`${repsec}run_factor`] = 3), update
}, drop_add_attack = function (cdata, v) {
    let update = {}, repsec = `repeating_attacks_${generateRowID()}_`;
    return update[`${repsec}fromcompendium`] = cdata.uniqueName, update[`${repsec}atkname`] = cdata.Name, update[`${repsec}options-flag`] = 0, update[`${repsec}category`] = cdata["Weapon Category"] || "", update[`${repsec}category`].toLowerCase().includes("ranged") ? (update[`${repsec}atktype`] = "ranged", update[`${repsec}dmgattr`] = "0") : (update[`${repsec}atktype`] = "melee", update[`${repsec}category`].toLowerCase().includes("two-handed") ? update[`${repsec}dmgattr`] = "strength_oneandahalf" : update[`${repsec}dmgattr`] = "strength"), update[`${repsec}type`] = cdata["Weapon Type"] || "", update[`${repsec}atkcritrange`] = (cdata["Critical Range"] || "20").substr(0, 2), update[`${repsec}atkrange`] = cdata.Range || "", "Damage (Medium)" in cdata && ["medium", "large", "huge", "gargantuan", "colossal"].includes(v.size || "medium") && (update[`${repsec}dmgbase`] = cdata["Damage (Medium)"]), "Damage (Small)" in cdata && ["fine", "diminutive", "tiny", "small"].includes(v.size || "medium") && (update[`${repsec}dmgbase`] = cdata["Damage (Small)"]), update[`${repsec}dmgtype`] = cdata["Damage Type"] || "", update[`${repsec}dmgcritmulti`] = parseInt((cdata["Critical Damage"] || "").replace(/\D+/g, "")) || 2, update[`${repsec}notes`] = cdata.Special || "", update
}, calc_ability = function (attr, v) {
    let update = {}, total = (parseInt(v[`${attr}_base`]) || 0) + (parseInt(v[`${attr}_race`]) || 0) + (parseInt(v[`${attr}_bonus`]) || 0);
    return ["strength", "dexterity"].includes(attr) && (total += parseInt(v[`${attr}_condition`]) || 0), update[attr] = Math.max(total, 0), "npc" in v && "1" != v.npc && (update[`${attr}_base_mod`] = Math.floor(((parseInt(v[`${attr}_base`]) || 0) + (parseInt(v[`${attr}_race`]) || 0) - 10) / 2)), update
}, update_mod = function (attr) {
    let fields = [attr];
    "dexterity" == attr && fields.push("dexterity_condition_nobonus"), getAttrs(fields, v => { setAttrs(calc_ability_mod(attr, v), { silent: !0 }) })
}, calc_ability_mod = function (attr, v) {
    let update = {}, mod = 0;
    return "" == String(v[attr]).replace(/[^\d]/gi, "") ? mod = 0 : (mod = Math.floor(((parseInt(String(v[attr]).replace(/[^\d\-]/gi, "")) || 0) - 10) / 2), "strength" == attr ? (update.strength_half_mod = Math.floor(.5 * mod), update.strength_oneandahalf_mod = Math.floor(1.5 * mod)) : "dexterity" == attr && (v.dexterity_condition_nobonus && "1" == v.dexterity_condition_nobonus && mod > 0 && (mod = 0), update.dexterity_half_mod = Math.floor(.5 * mod), update.dexterity_oneandahalf_mod = Math.floor(1.5 * mod))), update[attr + "_mod"] = mod, update
}, update_size = function (psize) {
    getAttrs(["npc"], v => {
        if ("1" == v.npc) {
            var update = {};
            update.size_display = getTranslationByKey(psize), setAttrs(update, { silent: !0 })
        } else setAttrs(calc_pc_size(psize), { silent: !0 }, () => { update_babs_all() })
    })
}, calc_pc_size = function (psize) {
    let atkac = 0, cmb = 0, fly = 0, stealth = 0, load = 1, obj_size = pfoglobals_size.find(size_item => size_item.size === (psize || "medium"));
    return _.isEmpty(obj_size) || (atkac = parseInt(obj_size.atkac) || 0, cmb = parseInt(obj_size.cmb) || 0, fly = parseInt(obj_size.fly) || 0, stealth = parseInt(obj_size.stealth) || 0, load = parseFloat(obj_size.load) || 1), update = { ac_size: atkac, bab_size: atkac, cmb_size: cmb, fly_size: fly, stealth_size: stealth, encumbrance_size: load }, update
}, update_initiative = function () { getAttrs(pfoglobals_initiative_fields, v => { "1" != v.npc && setAttrs(calc_initiative(v)) }) }, calc_initiative = function (v) { return { initiative: (parseInt(v.dexterity_mod) || 0) + (parseInt(v.initiative_misc) || 0) + (parseInt(v.initiative_bonus) || 0) } }, update_class_names = function (attr) {
    let update = {};
    getAttrs(["npc", "class1_name", "class2_name", "class3_name", "caster1_flag", "caster2_flag", "class1_level", "class2_level", "class3_level"], v => {
        if ("1" != v.npc) {
            let cls = "", cc1 = " ", cc2 = " ";
            v.class1_name && v.class1_name.length > 0 && (cls += v.class1_name, "0" != v.caster1_flag && (cc1 = v.class1_name)), v.class2_name && v.class2_name.length > 0 && (cls += cls.length > 0 ? " " + (parseInt(v.class1_level) || 1) + ", " : "", cls += v.class2_name + " " + (parseInt(v.class2_level) || 0), "0" != v.caster2_flag && (cc2 = v.class2_name)), v.class3_name && v.class3_name.length > 0 && (cls += (cls.length > 0 ? ", " : "") + v.class3_name + " " + (parseInt(v.class3_level) || 0)), update.class = cls, update.caster1_class = cc1, update.caster2_class = cc2, update.caster_flag = (parseInt(v.caster1_flag) || 0) + (parseInt(v.caster2_flag) || 0), setAttrs(update, { silent: !0 }, () => { (parseInt(update.caster_flag) || 0) > 0 && attr && ("caster1_flag" == attr ? update_spells_dc("caster1_ability") : "caster2_flag" == attr ? update_spells_dc("caster2_ability") : 2 == (parseInt(update.caster_flag) || 0) && ["class1_name", "class2_name"].includes(attr) && update_all_spells("all")) })
        }
    })
}, update_class_numbers = function (attr) {
    let update = {};
    getAttrs(["npc", "class1_" + attr, "class2_" + attr, "class3_" + attr], v => {
        if ("1" != v.npc) {
            let finalattr = "", total = 0;
            for (let i = 1;
                i < 4;
                i++)total += parseInt(v[`class${i}_${attr}`]) || 0;
            finalattr = ["level", "bab"].includes(attr) ? attr : ["speed"].includes(attr) ? attr + "_class" : attr + "_base", "bab" == attr && (update.bab_max = total), update[finalattr] = total, setAttrs(update, { silent: !1 }, () => { "level" == attr && (update_class_names(attr), getAttrs(pfoglobals_babs_fields, values => { setAttrs(calc_fob(values), { silent: !0 }, () => { update_attacks("all") }) })) })
        }
    })
}, update_hitdie = function () { getAttrs(["class_favored", "class1_hitdietype", "class2_hitdietype", "class3_hitdietype"], v => { setAttrs({ hitdietype: v["class" + (parseInt(v.class_favored) || 1) + "_hitdietype"] }, { silent: !0 }) }) }, update_ac_items = function () {
    let attrs = ["speed_race", "speed_class", "caster1_flag", "caster2_flag", "speed_armor", "armor_run_factor", "armor_check_penalty", "armor_spell_failure"];
    getSectionIDs("repeating_acitems", idarray => {
        _.each(idarray, itemid => { attrs.push(`repeating_acitems_${itemid}_equipped`, `repeating_acitems_${itemid}_ac_bonus`, `repeating_acitems_${itemid}_flatfooted_bonus`, `repeating_acitems_${itemid}_touch_bonus`, `repeating_acitems_${itemid}_natural_bonus`, `repeating_acitems_${itemid}_deflection_bonus`, `repeating_acitems_${itemid}_dodge_bonus`, `repeating_acitems_${itemid}_type`, `repeating_acitems_${itemid}_check_penalty`, `repeating_acitems_${itemid}_max_dex_bonus`, `repeating_acitems_${itemid}_spell_failure`, `repeating_acitems_${itemid}_spell_failure`, `repeating_acitems_${itemid}_speed20`, `repeating_acitems_${itemid}_speed30`, `repeating_acitems_${itemid}_run_factor`) }), getAttrs(attrs, v => {
            let update = {}, bonusarmor = 0, bonusshield = 0, bonusff = 0, bonustouch = 0, bonusnatural = 0, bonusdeflection = 0, bonusdodge = 0, checkpen = 0, maxdex = 99, spellf = 0, maxab = "-", run = 4, speedbase = (parseInt(v.speed_race) || 30) + (parseInt(v.speed_class) || 0), speedreduced = calc_reduced_speed(speedbase), speed = speedbase;
            _.each(idarray, itemid => { "1" == v[`repeating_acitems_${itemid}_equipped`] && ("shield" == v[`repeating_acitems_${itemid}_type`] ? bonusshield += parseInt(v[`repeating_acitems_${itemid}_ac_bonus`]) || 0 : bonusarmor += parseInt(v[`repeating_acitems_${itemid}_ac_bonus`]) || 0, bonusff += parseInt(v[`repeating_acitems_${itemid}_flatfooted_bonus`]) || 0, bonustouch += parseInt(v[`repeating_acitems_${itemid}_touch_bonus`]) || 0, bonusnatural = Math.max(bonusnatural, parseInt(v[`repeating_acitems_${itemid}_natural_bonus`]) || 0), bonusdeflection = Math.max(bonusdeflection, parseInt(v[`repeating_acitems_${itemid}_deflection_bonus`]) || 0), bonusdodge += parseInt(v[`repeating_acitems_${itemid}_dodge_bonus`]) || 0, checkpen += parseInt(v[`repeating_acitems_${itemid}_check_penalty`]) || 0, (v[`repeating_acitems_${itemid}_max_dex_bonus`] || "").replace(/[^\d]/gi, "").length ? maxdex = Math.min(maxdex, parseInt(v[`repeating_acitems_${itemid}_max_dex_bonus`].replace(/[^\d]/gi, ""))) : update[`repeating_acitems_${itemid}_max_dex_bonus`] = "-", spellf += parseInt(v[`repeating_acitems_${itemid}_spell_failure`]) || 0, ["heavy", "medium"].includes(v[`repeating_acitems_${itemid}_type`]) && (speed = Math.min(speed, speedbase, speedreduced)), run = Math.min(run, parseInt(v[`repeating_acitems_${itemid}_run_factor`]) || 4)) }), maxdex < 99 && (maxab = maxdex), _.extend(update, { ac_armor: bonusarmor, ac_shield: bonusshield, ac_flatfooted_items: bonusff, ac_touch_items: bonustouch, ac_natural_items: bonusnatural, ac_deflection_items: bonusdeflection, ac_dodge_items: bonusdodge, ac_ability_maximum: maxab, armor_check_penalty: checkpen, armor_spell_failure: spellf, speed_armor: speed, armor_run_factor: run }), setAttrs(update, { silent: !0 }, () => { update_ac_ability("ac_ability_maximum"), (parseInt(v.speed_armor) || 0) == speed && (parseInt(v.armor_run_factor) || 0) == run || update_speed(), (parseInt(v.armor_check_penalty) || 0) != checkpen && update_all_skills(), "1" != v.caster1_flag && "1" != v.caster2_flag || (parseInt(v.armor_spell_failure) || 0) == spellf || update_all_spells("all") })
        })
    })
}, update_ac_ability = function (attr) { getAttrs(pfoglobals_ac_ability_fields, v => { "1" != v.npc && setAttrs(calc_ac_ability(attr, v), { silent: !0 }, () => { update_ac() }) }) }, calc_ac_ability = function (attr, v) {
    let update = {}, secabmonk = parseInt(v.ac_secab_monk) || 0, primary = parseInt(v[v.ac_ability_primary + "_mod"]) || 0, secondary = parseInt(v[v.ac_ability_secondary + "_mod"]) || 0, maxmod = Math.min(parseInt(("" + v.ac_ability_maximum || "").replace(/[^\d]/gi, "99")), parseInt(v.encumbrance_ability_maximum) || 99), ffmod = 0;
    1 == secabmonk && (secondary < 0 || 99 != maxmod ? secondary = 0 : ffmod = secondary);
    let finalmod = Math.min(primary + secondary, maxmod);
    return 1 == (parseInt(v.ac_condition_nobonus) || 0) && (1 == secabmonk && 99 == maxmod ? (finalmod = secondary, ffmod = secondary) : finalmod > 0 && (finalmod = 0)), update.ac_ability_mod = finalmod, update.ac_ff_ability_mod = ffmod, update
}, update_ac = function () { getAttrs(pfoglobals_ac_fields, v => { "1" != v.npc && setAttrs(calc_ac(v), { silent: !0 }, () => { update_cmd() }) }) }, calc_ac = function (v) {
    let update = {}, ac = 0, actouch = 0, acff = 0, flag = 0, ability = parseInt(v.ac_ability_mod) || 0, size = parseInt(v.ac_size) || 0, armor = Math.max(parseInt(v.ac_armor) || 0, parseInt(v.ac_armor_bonus) || 0), shield = Math.max(parseInt(v.ac_shield) || 0, parseInt(v.ac_shield_bonus) || 0), natural = Math.max(parseInt(v.ac_natural_items) || 0, parseInt(v.ac_natural_bonus) || 0), deflection = Math.max(parseInt(v.ac_deflection_items) || 0, parseInt(v.ac_deflection_bonus) || 0), dodge = (parseInt(v.ac_dodge_items) || 0) + (parseInt(v.ac_dodge_bonus) || 0), touch_bonus = parseInt(v.ac_touch_items) || 0, flatfooted_bonus = parseInt(v.ac_flatfooted_items) || 0, bonus = parseInt(v.ac_bonus) || 0, misc = parseInt(v.ac_misc) || 0, noflatflooted = parseInt(v.ac_noflatflooted) || 0, touchshield = parseInt(v.ac_touchshield) || 0, secabmonk = parseInt(v.ac_secab_monk) || 0, condition = parseInt(v.ac_condition) || 0;
    if (ac = 10 + bonus + ability + armor + shield + size + natural + deflection + misc + dodge + condition, 1 == noflatflooted) acff = ac;
    else if (acff = 10 + bonus + (ability < 0 ? ability : 0) + armor + shield + size + natural + deflection + misc + condition, 1 == secabmonk) {
        let ffmod = parseInt(v.ac_ff_ability_mod) || 0;
        acff += ffmod > 0 ? ffmod : 0
    } return acff += flatfooted_bonus, actouch = 10 + bonus + ability + size + deflection + misc + dodge + condition, 1 == touchshield && (actouch += shield), actouch += touch_bonus, flag = 0 != bonus || (parseInt(v.ac_armor_bonus) || 0) > (parseInt(v.ac_armor) || 0) || (parseInt(v.ac_shield_bonus) || 0) > (parseInt(v.ac_shield) || 0) || (parseInt(v.ac_natural_bonus) || 0) > (parseInt(v.ac_natural_items) || 0) || (parseInt(v.ac_deflection_bonus) || 0) > (parseInt(v.ac_deflection_items) || 0) || 0 != (parseInt(v.ac_dodge_bonus) || 0) ? 1 : 0, update.ac = ac, update.ac_touch = actouch, update.ac_flatfooted = acff, update.ac_bonus_flag = flag, update.ac_natural = natural, update.ac_dodge = dodge, update.ac_deflection = deflection, update
}, update_cmd = function () { getAttrs(pfoglobals_babs_fields, v => { "1" != v.npc && setAttrs(calc_cmd(v), { silent: !0 }) }) }, calc_cmd = function (v) {
    let acmod = parseInt(v.ac_ability_mod) || 0;
    return acmod > 0 && "1" == v.ac_condition_nobonus && (acmod = 0), { cmd_mod: 10 + (parseInt(v.bab) || 0) + (parseInt(v.strength_mod) || 0) + acmod + (parseInt(v.cmb_size) || 0) + (parseInt(v.ac_dodge_bonus) || 0) + (parseInt(v.ac_dodge_items) || 0) + Math.max(parseInt(v.ac_deflection_bonus) || 0, parseInt(v.ac_deflection_items) || 0) + (parseInt(v.cmd_condition) || 0) + (parseInt(v.cmd_misc) || 0) + (parseInt(v.cmd_bonus) || 0) }
}, update_sr = function () { getAttrs(["npc", "sr_base", "sr_bonus"], v => { setAttrs(calc_sr(v), { silent: !0 }) }) }, calc_sr = function (v) {
    let update = {};
    return "npc" in v && "1" != v.npc && (update.sr = (parseInt(v.sr_base) || 0) + (parseInt(v.sr_bonus) || 0)), update
}, update_save = function (attr) { getAttrs(pfoglobals_save_fields, v => { "1" != v.npc && setAttrs(calc_save(attr, v)) }) }, calc_save = function (attr, v) {
    let update = {};
    return v[attr + "_ability_mod"] != v[v[attr + "_ability"] + "_mod"] && (v[attr + "_ability_mod"] = v[v[attr + "_ability"] + "_mod"], update[attr + "_ability_mod"] = v[attr + "_ability_mod"]), update[attr] = pfoglobals_save_attr.map(fld => parseInt(v[attr + "_" + fld]) || 0).reduce((total, val) => total + val), update
}, update_babs_all = function () { getAttrs(pfoglobals_babs_fields, v => { "1" != v.npc && setAttrs(calc_babs_all(v), { silent: !0 }, () => { update_attacks("all") }) }) }, update_babs = function (attr) { getAttrs(pfoglobals_babs_fields, v => { "1" != v.npc && setAttrs(calc_babs(attr, v), { silent: !0 }, () => { update_attacks(attr) }) }) }, calc_babs_all = function (v) {
    let babarray = [], multi = parseInt(v.bab) || 0;
    do { babarray.push(multi), multi -= 5 } while (multi > 0);
    v.bab_multi = babarray;
    let update = { bab_multi: babarray };
    return _.extend(update, calc_babs("cmb", v), calc_babs("melee", v), calc_babs("ranged", v), calc_cmd(v), calc_fob(v)), update
}, calc_babs = function (attr, v) {
    let babarray, update = {}, atkarray = [], sizemod = 0;
    return babarray = v.bab_multi ? JSON.parse("[" + v.bab_multi + "]") : [], sizemod = "cmb" === attr ? parseInt(v.cmb_size) || 0 : parseInt(v.bab_size) || 0, v[attr + "_ability_mod"] != v[v[attr + "_ability"] + "_mod"] && (v[attr + "_ability_mod"] = v[v[attr + "_ability"] + "_mod"], update[attr + "_ability_mod"] = v[attr + "_ability_mod"]), update[attr + "_mod"] = (parseInt(v.bab) || 0) + sizemod + (parseInt(v[attr + "_ability_mod"]) || 0) + (parseInt(v[attr + "_misc"]) || 0) + (parseInt(v[attr + "_bonus"]) || 0), babarray.length ? _.each(babarray, babval => { atkarray.push((parseInt(babval) || 0) + sizemod + (parseInt(v[attr + "_ability_mod"]) || 0) + (parseInt(v[attr + "_misc"]) || 0) + (parseInt(v[attr + "_bonus"]) || 0)) }) : atkarray.push(update[attr + "_mod"]), update[attr + "_multi"] = atkarray, update
}, calc_fob = function (v) {
    let lvl = 0, bab = 0, fob = 0, multi = 0, farray = [], fobarray = [], monkclass = 0, atksperlevel = [2, 2, 2, 2, 2, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7];
    for (let i = 1;
        i < 4;
        i++)v[`class${i}_name`] && v[`class${i}_name`].match(/monk/i) && !monkclass ? (lvl = parseInt(v[`class${i}_level`]) || 1, monkclass = i) : bab += parseInt(v[`class${i}_bab`]) || 0;
    if (lvl > 0) {
        multi = fob = bab + lvl;
        do { farray.push(multi), multi -= 5 } while (multi > 0);
        _.each(farray, f => { fobarray.push(f - 2, f - 2) }), fobarray = fobarray.slice(0, atksperlevel[lvl - 1])
    } else fobarray.push(0);
    return { fob: fob, fob_multi: fobarray }
}, update_attacks = function (update_id) { "-" === update_id.substring(0, 1) && 20 === update_id.length ? do_update_attack("", [{ section: "attacks", ids: [update_id], attrs: pfoglobals_atk_attr }]) : ["strength", "strength_oneandahalf", "strength_half", "dexterity", "dexterity_half", "dexterity_oneandahalf", "constitution", "intelligence", "wisdom", "charisma", "melee", "ranged", "cmb", "bab", "bab_max", "all"].includes(update_id) && get_repsec_ids(JSON.parse(JSON.stringify(pfoglobals_repsec_atk)), repsec_agr => { do_update_attack(update_id, repsec_agr) }) }, do_update_attack = function (attributename = "", repsec_agr) {
    let attack_attribs = get_repsec_fields(repsec_agr, pfoglobals_atk_fields);
    attack_attribs = attack_attribs.concat(pfoglobals_babs_fields, pfoglobals_abilities), getAttrs(attack_attribs, v => { "npc" in v && "1" != v.npc && setAttrs(calc_attacks(repsec_agr, v, attributename), { silent: !0 }) })
}, calc_attacks = function (repsec_agr, v, attributename = "") {
    let update = {};
    return _.each(repsec_agr, current_section => {
        _.each(current_section.ids, attackid => {
            if (0 === attributename.length || "all" == attributename || v[`repeating_attacks_${attackid}_atktype`] && v[`repeating_attacks_${attackid}_atktype`].includes(attributename) || v[`repeating_attacks_${attackid}_atktype2`] && v[`repeating_attacks_${attackid}_atktype2`].includes(attributename) || v[`repeating_attacks_${attackid}_dmgattr`] && v[`repeating_attacks_${attackid}_dmgattr`].includes(attributename) || v[`repeating_attacks_${attackid}_dmg2attr`] && v[`repeating_attacks_${attackid}_dmg2attr`].includes(attributename)) {
                let i = 0, stemp = "", atkbonusarray = [], atkdmgbonus = 0, atkdmg2bonus = 0, atkdisplay = " ", rollbase = "", rollatkarray = [], rolldmg = "", rolldmgonly = "", rolltype = "", rollnotes = "", conditions = "", condatknotes = "", conddmgnotes = "", atktypearray = [], atkrange = "", atkname = v[`repeating_attacks_${attackid}_atkname`] || "???", atkflag = v[`repeating_attacks_${attackid}_atkflag`] || "{{attack=1}}", atktype2 = parseInt(v[`${v[`repeating_attacks_${attackid}_atktype2`]}_mod`]) || 0, atkmod = v[`repeating_attacks_${attackid}_atkmod`] || "0", atkvs = v[`repeating_attacks_${attackid}_atkvs`] || "ac", atkcritrange = parseInt(v[`repeating_attacks_${attackid}_atkcritrange`]) || 20, dmgflag = v[`repeating_attacks_${attackid}_dmgflag`] || "{{damage=1}} {{dmg1flag=1}}", dmgbase = v[`repeating_attacks_${attackid}_dmgbase`] || "0", dmgattr = parseInt(v[`${v[`repeating_attacks_${attackid}_dmgattr`] || "strength"}_mod`]) || 0, dmgmod = v[`repeating_attacks_${attackid}_dmgmod`] || "0", dmgbonusdice = v[`repeating_attacks_${attackid}_dmgbonusdice`] || "", dmgcritmulti = parseInt(v[`repeating_attacks_${attackid}_dmgcritmulti`]) || 2, dmgtype = v[`repeating_attacks_${attackid}_dmgtype`] || "", dmg2flag = v[`repeating_attacks_${attackid}_dmg2flag`] || "0", dmg2name = v[`repeating_attacks_${attackid}_dmg2name`] || getTranslationByKey("damage2"), dmg2base = v[`repeating_attacks_${attackid}_dmg2base`] || "0", dmg2attr = parseInt(v[`${v[`repeating_attacks_${attackid}_dmg2attr`]}_mod`]) || 0, dmg2mod = v[`repeating_attacks_${attackid}_dmg2mod`] || "0", dmg2bonusdice = v[`repeating_attacks_${attackid}_dmg2bonusdice`] || "", dmg2critmulti = parseInt(v[`repeating_attacks_${attackid}_dmg2critmulti`]) || 1, dmg2type = v[`repeating_attacks_${attackid}_dmg2type`] || "", descflag = v[`repeating_attacks_${attackid}_descflag`] || "0", atkdesc = v[`repeating_attacks_${attackid}_atkdesc`] || "", atknotes = v[`repeating_attacks_${attackid}_notes`] || "", atktmpbonus = parseInt(v.attack_bonus) || 0, dmgtmpbonus = parseInt(v.damage_bonus) || 0, multi = "";
                if (multi = ["bab", "melee", "ranged", "cmb", "fob"].includes(v[`repeating_attacks_${attackid}_atktype`]) && v[`${v[`repeating_attacks_${attackid}_atktype`]}_multi`] ? v[`${v[`repeating_attacks_${attackid}_atktype`]}_multi`] : "bab_max" == v[`repeating_attacks_${attackid}_atktype`] ? parseInt(v.bab) || 0 : parseInt(v[`${v[`repeating_attacks_${attackid}_atktype`]}_mod`]) || 0, atktypearray = JSON.parse(`[${multi}]`), _.each(atktypearray, atkvalue => { atkbonusarray.push((parseInt(atkvalue) || 0) + atktype2 + parse_formula(atkmod, v) + atktmpbonus) }), "ranged" == v[`repeating_attacks_${attackid}_atktype`] || (v[`repeating_attacks_${attackid}_atkrange`] || "").trim().length ? dmgtmpbonus += parseInt(v.ranged_damage_bonus) || 0 : dmgtmpbonus += parseInt(v.melee_damage_bonus) || 0, atkdmgbonus = dmgattr + parse_formula(dmgmod, v) + dmgtmpbonus, atkdmg2bonus = dmg2attr + parse_formula(dmg2mod, v) + dmgtmpbonus, "0" != atkflag) for (atkdisplay = "", "0" != v[`repeating_attacks_${attackid}_atktype`] && ("bab_max" == v[`repeating_attacks_${attackid}_atktype`] ? atkdisplay += pfoglobals_i18n_obj.bab : atkdisplay += pfoglobals_i18n_obj[v[`repeating_attacks_${attackid}_atktype`]]), v[`repeating_attacks_${attackid}_atktype2`] && "0" != v[`repeating_attacks_${attackid}_atktype2`] && (atkdisplay += (atkdisplay.trim().length ? "+" : "") + pfoglobals_i18n_obj[v[`repeating_attacks_${attackid}_atktype2`]]), atkdisplay = `(${atkdisplay} ${pfoglobals_i18n_obj.vs} ${pfoglobals_i18n_obj[atkvs]})`, update[`repeating_attacks_${attackid}_atkdisplay`] = atkdisplay, i = 0;
                    i < 7;
                    i++)update[`repeating_attacks_${attackid}_atkbonusdisplay${i > 0 ? i : ""}`] = i in atkbonusarray ? `${i > 0 ? "/" : ""}${atkbonusarray[i] < 0 ? "" : "+"}${atkbonusarray[i]}` : i > 0 ? " " : "-";
                else for (update[`repeating_attacks_${attackid}_atkdisplay`] = " ", i = 0;
                    i < 7;
                    i++)update[`repeating_attacks_${attackid}_atkbonusdisplay${i > 0 ? i : ""}`] = i > 0 ? " " : "-";
                if ("0" != dmgflag ? (update[`repeating_attacks_${attackid}_atkdmgdisplay`] = `${dmgbase}${atkdmgbonus < 0 ? "" : "+"}${atkdmgbonus}`, dmgbonusdice && (update[`repeating_attacks_${attackid}_atkdmgdisplay`] += `+(${dmgbonusdice})`)) : update[`repeating_attacks_${attackid}_atkdmgdisplay`] = "-", "0" != dmg2flag ? (update[`repeating_attacks_${attackid}_atkdmgdisplay2`] = `${dmg2base}${atkdmg2bonus < 0 ? "" : "+"}${atkdmg2bonus}`, dmg2bonusdice && (update[`repeating_attacks_${attackid}_atkdmgdisplay2`] += `+(${dmg2bonusdice})`)) : update[`repeating_attacks_${attackid}_atkdmgdisplay2`] = "-", "0" != descflag && (atkdesc = `{{descflag=[[1]]}}{{desc=${atkdesc}}}`), "0" != v.rollnotes_attack && (rollnotes = `{{shownotes=[[1]]}}{{notes=${atknotes}}}`), v[`repeating_attacks_${attackid}_atkrange`] && (atkrange = `{{range=${v[`repeating_attacks_${attackid}_atkrange`]}}}`), "0" != atkflag) {
                    for (rolltype += "attack", rollbase += `${atkflag}${atkrange}`, i = 0;
                        i < 7;
                        i++)i in atktypearray ? (stemp = `${atktypearray[i]}[${pfoglobals_i18n_obj[`${v[`repeating_attacks_${attackid}_atktype`]}`]}] + ${atktype2}[${pfoglobals_i18n_obj["0" == (v[`repeating_attacks_${attackid}_atktype2`] || "0") ? "ability" : v[`repeating_attacks_${attackid}_atktype2`]]}] + ${atkmod}[MOD] + ${atktmpbonus}[TEMP] + (@{attack_condition})[CONDITION] + @{rollmod_attack}[QUERY]`, stemp = `{{roll${i > 0 ? i : ""}=[[1d20cs>${atkcritrange} + ${stemp} ]]}} {{critconfirm${i > 0 ? i : ""}=[[1d20cs20 + ${stemp} + @{critconfirm_bonus}[CRIT CONFIRM BONUS] ]]}}`, 0 == i && (stemp += `{{atkvs=${atkdisplay}}}`), rollatkarray.push(stemp), rollbase += stemp) : rollatkarray.push("");
                    "0" != descflag && (rollatkarray[0] += atkdesc, rollbase += atkdesc), "0" != v.rollnotes_attack && (rollatkarray[0] += rollnotes, rollbase += rollnotes), conditions += "{{conditionsflag=[[@{attack_condition}]]}} {{conditions=@{conditions_display}}}", condatknotes += `${"cmb" == `${v[`repeating_attacks_${attackid}_atktype`]}` ? "@{cmb_condition_note}" : ""} @{attack_condition_note}`
                } if ("0" != dmgflag || "0" != dmg2flag) {
                    rolltype += "damage";
                    let dmgrollbase = "", dmgrollcrit = "", dmg2rollbase = "", dmg2rollcrit = "";
                    if ("0" != dmgflag) {
                        if (dmgrollbase = `${dmgbase}+${dmgattr}[${pfoglobals_i18n_obj["0" == (v[`repeating_attacks_${attackid}_dmgattr`] || "0") ? "ability" : v[`repeating_attacks_${attackid}_dmgattr`]]}] + ${dmgmod}[MOD] + ${dmgtmpbonus}[TEMP] + @{rollmod_damage}[QUERY]`, dmgbonusdice && (dmgrollbase += ` + ${dmgbonusdice}[BONUS DICE]`), dmgcritmulti > 1) {
                            for (i = 1;
                                i <= dmgcritmulti;
                                i++)dmgrollcrit += `${dmgrollcrit.length ? "+" : ""}${dmgbase}`;
                            dmgrollcrit = `((${dmgrollcrit}) + (${dmgattr}[${pfoglobals_i18n_obj["0" == (v[`repeating_attacks_${attackid}_dmgattr`] || "0") ? "ability" : v[`repeating_attacks_${attackid}_dmgattr`]]}] + ${dmgmod}[MOD] + ${dmgtmpbonus}[TEMP] + @{rollmod_damage}[QUERY]) * ${dmgcritmulti})`, dmgbonusdice && (dmgrollcrit += ` + ${dmgbonusdice}[BONUS DICE]`)
                        }
                        if ("0" != atkflag && atktypearray.length > 1) for (i = 0;
                            i < atktypearray.length;
                            i++)rolldmg += `{{roll${i > 0 ? i : ""}dmg1=[[${dmgrollbase}]]}} {{roll${i > 0 ? i : ""}dmg1type=${dmgtype}}}`, dmgcritmulti > 1 && (rolldmg += `{{roll${i > 0 ? i : ""}dmg1crit=[[${dmgrollcrit}]]}}`);
                        else rolldmg += `${dmgflag} {{dmg1=[[${dmgrollbase}]]}}{{dmg1type=${dmgtype}}}`, dmgcritmulti > 1 && (rolldmg += `{{dmg1crit=[[${dmgrollcrit}]]}}`);
                        rolldmgonly += `${dmgflag} {{dmg1=[[${dmgrollbase}]]}} {{dmg1type=${dmgtype}}}`, dmgcritmulti > 1 && (rolldmgonly += `{{dmg1crit=[[${dmgrollcrit}]]}}`)
                    } if ("0" != dmg2flag) {
                        if (rolldmg += `{{dmg2name=${dmg2name}}}`, rolldmgonly += `{{dmg2name=${dmg2name}}}`, dmg2rollbase = `${dmg2base} + ${dmg2attr}[${pfoglobals_i18n_obj["0" == (v[`repeating_attacks_${attackid}_dmg2attr`] || "0") ? "ability" : v[`repeating_attacks_${attackid}_dmg2attr`]]}] + ${dmg2mod}[MOD] + ${dmgtmpbonus}[TEMP] + @{rollmod_damage}[QUERY]`, dmg2bonusdice && (dmg2rollbase += "+" + dmg2bonusdice + "[BONUS DICE]"), dmg2critmulti > 1) {
                            for (i = 1;
                                i <= dmg2critmulti;
                                i++)dmg2rollcrit += `${dmg2rollcrit.length ? "+" : ""}${dmg2base}`;
                            dmg2rollcrit = `((${dmg2rollcrit}) + (${dmg2attr}[${pfoglobals_i18n_obj["0" == (v[`repeating_attacks_${attackid}_dmg2attr`] || "0") ? "ability" : v[`repeating_attacks_${attackid}_dmg2attr`]]}] + ${dmg2mod}[MOD] + ${dmgtmpbonus}[TEMP] + @{rollmod_damage}[QUERY]) * ${dmg2critmulti})`, dmg2bonusdice && (dmg2rollcrit += ` + ${dmg2bonusdice}[BONUS DICE]`)
                        } else dmg2rollcrit = "";
                        if ("0" != atkflag && atktypearray.length > 1) for (i = 0;
                            i < atktypearray.length;
                            i++)rolldmg += `{{roll${i > 0 ? i : ""}dmg2=[[${dmg2rollbase}]]}} {{roll${i > 0 ? i : ""}dmg2type=${dmg2type}}}`, dmg2critmulti > 1 && (rolldmg += `{{roll${i > 0 ? i : ""}dmg2crit=[[${dmg2rollcrit}]]}}`);
                        else rolldmg += `${dmg2flag} {{dmg2=[[${dmg2rollbase}]]}} {{dmg2type=${dmg2type}}}`, dmg2critmulti > 1 && (rolldmg += `{{dmg2crit=[[${dmg2rollcrit}]]}}`);
                        rolldmgonly += `${dmg2flag} {{dmg2=[[${dmg2rollbase}]]}} {{dmg2type=${dmg2type}}}`, dmg2critmulti > 1 && (rolldmgonly += `{{dmg2crit=[[${dmg2rollcrit}]]}}`)
                    } "0" != descflag && "0" == atkflag && (rolldmg += atkdesc, rolldmgonly += atkdesc), "0" != v.rollnotes_attack && "0" == atkflag && (rolldmg += rollnotes, rolldmgonly += rollnotes), rollbase += rolldmg, conddmgnotes += "@{damage_condition_note}"
                } let j = 0, stempatk = "", stempdmgbase = "", stempdmg = "", stempdmgcrit = "";
                for (i = 1;
                    i < 4;
                    i++)if (j = i + 6, v[`repeating_attacks_${attackid}_atkextra${i}flag`] && "1" == v[`repeating_attacks_${attackid}_atkextra${i}flag`]) {
                        if (stemp = `{{roll${j}name=${v[`repeating_attacks_${attackid}_atkextra${i}name`] || "Extra #1"}}}`, stemp += `{{roll${j}=[[1d20cs>${v[`repeating_attacks_${attackid}_atkextra${i}critrange`] || "20"}`, stempatk = v[`repeating_attacks_${attackid}_atkextra${i}type`] && "0" != v[`repeating_attacks_${attackid}_atkextra${i}type`] ? ` + @{${v[`repeating_attacks_${attackid}_atkextra${i}type`]}}[${pfoglobals_i18n_obj[`${v[`repeating_attacks_${attackid}_atkextra${i}type`]}`]}]` : " + 0", v[`repeating_attacks_${attackid}_atkextra${i}type2`] && "0" != v[`repeating_attacks_${attackid}_atkextra${i}type2`] && (stempatk += ` + @{${v[`repeating_attacks_${attackid}_atkextra${i}type2`]}}[${pfoglobals_i18n_obj[`${v[`repeating_attacks_${attackid}_atkextra${i}type2`]}`]}]`), v[`repeating_attacks_${attackid}_atkextra${i}mod`] && "0" != v[`repeating_attacks_${attackid}_atkextra${i}mod`] ? stempatk += ` + ${v[`repeating_attacks_${attackid}_atkextra${i}mod`]}[MOD]` : stempatk += " + 0[MOD]", stemp += `${stempatk += `+ ${atktmpbonus}[TEMP] + (@{attack_condition})[CONDITION] + @{rollmod_attack}[QUERY]`}]]}}`, stemp += `{{critconfirm${j}=[[1d20cs20${stempatk} + @{critconfirm_bonus}[CRIT CONFIRM BONUS]]]}}`, stempdmgbase = v[`repeating_attacks_${attackid}_atkextra${i}dmgbase`] || "0", stempdmg = "", "0" != (v[`repeating_attacks_${attackid}_atkextra${i}dmgattr`] || "") ? stempdmg += `@{${v[`repeating_attacks_${attackid}_atkextra${i}dmgattr`]}}[${pfoglobals_i18n_obj[`${v[`repeating_attacks_${attackid}_atkextra${i}dmgattr`]}`]}]` : stempdmg += `0[${getTranslationByKey("ability")}]`, v[`repeating_attacks_${attackid}_atkextra${i}dmgmod`] ? stempdmg += ` + ${v[`repeating_attacks_${attackid}_atkextra${i}dmgmod`] || "0"}[MOD]` : stempdmg += " + 0[MOD]", stempdmg += " + @{damage_bonus}[TEMP]", "ranged_mod" == (v[`repeating_attacks_${attackid}_atkextra${i}type`] || "melee_mod") ? stempdmg += " + @{ranged_damage_bonus}[RANGED TEMP]" : stempdmg += " + @{melee_damage_bonus}[MELEE TEMP]", stemp += `{{roll${j}dmg1=[[${stempdmgbase} + ${stempdmg += " + @{rollmod_damage}[QUERY]"}]]}}`, stempdmgcrit = "", v[`repeating_attacks_${attackid}_atkextra${i}dmgcritmulti`] && parseInt(v[`repeating_attacks_${attackid}_atkextra${i}dmgcritmulti`] || 0) > 1 && "0" != stempdmgbase) {
                            for (let g = 0;
                                g < (parseInt(v[`repeating_attacks_${attackid}_atkextra${i}dmgcritmulti`]) || 2);
                                g++)stempdmgcrit += `${g > 0 ? " + " : ""}${stempdmgbase}`;
                            stemp += `{{roll${j}dmg1crit=[[(${stempdmgcrit}) + ((${stempdmg}) * ${v[`repeating_attacks_${attackid}_atkextra${i}dmgcritmulti`]})]]}}`
                        } rollbase += stemp += `{{roll${j}dmg1type=${v[`repeating_attacks_${attackid}_atkextra${i}dmgtype`] || ""}}}`, update[`repeating_attacks_${attackid}_rollbase_atk${j}`] = `@{whispertype} &{template:pc} {{smallname=${atkname}}} {{type=attack}} {{showchar=@{rollshowchar}}} {{charname=@{character_name}}} ${atkflag} ${stemp} ${conditions} {{conditionsnote=${condatknotes}}}`
                    } else update[`repeating_attacks_${attackid}_rollbase_atk${j}`] = "";
                for (update[`repeating_attacks_${attackid}_rollbase_dmg`] = rolldmg ? `@{whispertype} &{template:pc} {{smallname=${atkname}}} {{type=damage}} {{showchar=@{rollshowchar}}} {{charname=@{character_name}}} {{nonlethal=[[1[Nonlethal]]]}} ${rolldmgonly} {{conditionsnote=${conddmgnotes}}}` : " ", update[`repeating_attacks_${attackid}_rollbase`] = rollbase ? `@{whispertype} &{template:pc} {{name=${atkname}}} {{type=${rolltype}}} {{showchar=@{rollshowchar}}} {{charname=@{character_name}}} {{nonlethal=[[1[Nonlethal]]]}} ${rollbase} ${conditions} {{conditionsnote=${condatknotes}${conddmgnotes}}}` : " ", i = 0;
                    i < 7;
                    i++)i in rollatkarray && rollatkarray[i] ? update[`repeating_attacks_${attackid}_rollbase_atk${i > 0 ? i : ""}`] = `@{whispertype} &{template:pc} {{${i > 0 ? "small" : ""}name=${atkname}}} {{type=attack}} {{showchar=@{rollshowchar}}} {{charname=@{character_name}}} {{nonlethal=[[1[Nonlethal]]]}} ${atkflag} ${rollatkarray[i]} ${conditions} {{conditionsnote=${condatknotes}}}` : update[`repeating_attacks_${attackid}_rollbase_atk${i > 0 ? i : ""}`] = ""
            }
        })
    }), update
}, update_damage_bonus_flag = function () { getAttrs(["damage_bonus", "melee_damage_bonus", "ranged_damage_bonus"], v => { setAttrs(calc_damage_bonus_flag(v), { silent: !0 }, () => { update_attacks("all") }) }) }, calc_damage_bonus_flag = function (v) {
    let update = {};
    return (parseInt(v.damage_bonus) || 0) + (parseInt(v.melee_damage_bonus) || 0) + (parseInt(v.ranged_damage_bonus) || 0) > 0 ? update.damage_bonus_flag = 1 : update.damage_bonus_flag = 0, update
}, update_npc_attack = function (type, id) {
    let base = "repeating_npcatk-" + type + "_" + id + "_", fields = [base + "atkname", base + "atkflag", base + "atkmod", base + "multipleatk_flag", base + "atkmod2", base + "atkmod3", base + "atkmod4", base + "atkmod5", base + "atkmod6", base + "atkmod7", base + "atkmod8", base + "atkmod9", base + "atkcritrange", base + "dmgflag", base + "dmgbase", base + "dmgtype", base + "dmgcritmulti", base + "dmg2flag", base + "dmg2base", base + "dmg2type", base + "dmg2critmulti"];
    "ranged" == type && fields.push(base + "atkrange"), getAttrs(fields, v => { setAttrs(calc_npc_attack(type, id, v), { silent: !0 }) })
}, calc_npc_attack = function (type, id, v) {
    let base = `repeating_npcatk-${type}_${id}_`, update = {}, display = "", multi = "", sdmg1 = "", sdmg2 = "", scrit1 = "", scrit2 = "";
    display = v[`${base}atkname`], display += ` ${(parseInt(v[`${base}atkmod`]) || 0) > 0 ? " + " : ""}${v[`${base}atkmod`]}`;
    let dmgcritmulti = parseInt(v[`${base}dmgcritmulti`]) || 2, dmg2critmulti = parseInt(v[`${base}dmg2critmulti`]) || 1;
    if (multi = "{{roll=[[1d20cs>@{atkcritrange}+@{atkmod}[MOD]+@{rollmod_attack}[QUERY]]]}}{{critconfirm=[[1d20cs20+@{atkmod}[MOD]+@{rollmod_attack}[QUERY]]]}}", v[`${base}dmgflag`] && v[`${base}dmgbase`] && "0" != v[`${base}dmgflag`] && v[`${base}dmgbase`].length > 0 && (multi += `{{rolldmg1=${sdmg1 = `[[${v[`${base}dmgbase`]} + @{rollmod_damage}[QUERY]]]`}}}{{rolldmg1type=@{dmgtype}}}`, dmgcritmulti > 1)) {
        for (scrit1 = "", i = 1;
            i <= dmgcritmulti;
            i++)scrit1 += `${scrit1.length > 0 ? " + " : ""}${v[`${base}dmgbase`]}`;
        multi += `{{rolldmg1crit=${scrit1 = `[[(${scrit1}) + (@{rollmod_damage}[QUERY]*${dmgcritmulti})]]`}}}`
    } if (v[`${base}dmg2flag`] && v[`${base}dmg2base`] && "0" != v[`${base}dmg2flag`] && v[`${base}dmg2base`].length > 0 && (multi += `{{rolldmg2=${sdmg2 = `[[${v[`${base}dmg2base`]} + @{rollmod_damage}[QUERY]]]`}}} {{rolldmg2type=@{dmg2type}}}`, dmg2critmulti > 1)) {
        for (scrit2 = "", i = 1;
            i <= dmg2critmulti;
            i++)scrit2 += `${scrit2.length > 0 ? " + " : ""}${v[`${base}dmg2base`]}`;
        multi += `{{rolldmg2crit=${scrit2 = `[[(${scrit2}) + (@{rollmod_damage}[QUERY] * ${dmg2critmulti})]]`}}}`
    } if ("1" == (v[`${base}multipleatk_flag`] || "0")) for (var i = 2;
        i < 10;
        i++)v[`${base}atkmod${i}`] && (display += `/${(parseInt(v[`${base}atkmod${i}`]) || 0) > 0 ? "+" : ""}${v[`${base}atkmod${i}`]}`, multi += `{{roll${i - 1}=[[1d20cs>@{atkcritrange} + @{atkmod${i}}[MOD] + @{rollmod_attack}[QUERY]]]}} {{critconfirm${i - 1}=[[1d20cs20 + @{atkmod${i}}[MOD] + @{rollmod_attack}[QUERY]]]}}`, sdmg1.length && (multi += `{{roll${i - 1}dmg1=${sdmg1}}} {{roll${i - 1}dmg1type=${v[`${base}dmgtype`]}}}`, dmgcritmulti > 1 && (multi += `{{roll${i - 1}dmg1crit=${scrit1}}}`)), "1" == v[`${base}dmg2flag`] && (multi += `{{roll${i - 1}dmg2=${sdmg2}}} {{roll${i - 1}dmg2type=${v[`${base}dmg2type`]}}}`, dmg2critmulti > 1 && (multi += `{{roll${i - 1}dmg2crit=${scrit2}}}`)));
    if ("ranged" == type && (v[`${base}atkrange`] || "").length && (display += ` ${v[`${base}atkrange`]}`), "0" != (v[`${base}dmgflag`] || "0") || "0" != (v[`${base}dmg2flag`] || "0")) {
        let dmg = "", dmg1 = "", dmg2 = "";
        "0" != (v[`${base}dmgflag`] || "0") && (dmg1 += v[`${base}dmgbase`], (parseInt(v[`${base}atkcritrange`]) || 20) < 20 && (dmg1 += `/${v[`${base}atkcritrange`]}-20`), 2 != (parseInt(v[`${base}dmgcritmulti`]) || 2) && (dmg1 += `/x${v[`${base}dmgcritmulti`]}`), "" != v[`${base}dmgtype`] && (dmg1 += ` ${v[`${base}dmgtype`]}`)), "0" != (v[`${base}dmg2flag`] || "0") && ("0" != v[`${base}dmg2base`].trim() && (dmg2 += v[`${base}dmg2base`]), "" != v[`${base}dmg2type`] && (dmg2 += ` ${v[`${base}dmg2type`]}`), 1 != (parseInt(v[`${base}dmg2critmulti`]) || 1) && (dmg2 += `/x${v[`${base}dmg2critmulti`]}`)), (dmg = `${dmg1}${dmg2.length > 0 ? ", " : ""}${dmg2}`).length > 0 && (display += ` (${dmg})`)
    } return update[`${base}atkdisplay`] = display, update[`${base}multipleatk`] = multi, update
}, update_traits = function (update_id) { "-" === update_id.substring(0, 1) && 20 === update_id.length ? do_update_traits([{ section: "abilities", ids: [update_id], attrs: pfoglobals_abilities_attr }]) : "all" == update_id && get_repsec_ids(JSON.parse(JSON.stringify(pfoglobals_repsec_traits)), repsec_agr => { do_update_traits(repsec_agr) }) }, do_update_traits = function (repsec_agr) {
    let attribs = get_repsec_fields(repsec_agr);
    attribs = attribs.concat(["level"], pfoglobals_abilities, pfoglobals_mods, pfoglobals_babs_fields), getAttrs(attribs, v => { "npc" in v && "1" != v.npc && setAttrs(calc_traits(repsec_agr, v), { silent: !0 }) })
}, calc_traits = function (repsec_agr, v) {
    let update = {};
    return _.each(repsec_agr, current_section => {
        _.each(current_section.ids, id => {
            let perday = 0;
            `repeating_abilities_${id}_perday_qty` in v && v[`repeating_abilities_${id}_perday_qty`].toString().trim().length && (perday = parse_formula("" + v[`repeating_abilities_${id}_perday_qty`], v)), update[`repeating_abilities_${id}_perday_max`] = perday > 0 ? perday : ""
        })
    }), update
}, update_all_skills = function () {
    get_repsec_ids(JSON.parse(JSON.stringify(pfoglobals_repsec_skills)), repsec_agr => {
        let fixskill_fields = pfoglobals_skill_fields;
        _.each(pfoglobals_skill_list, skillname => { fixskill_fields.push(...pfoglobals_skill_attr.map(skillattr => `${skillname}_${skillattr}`)) });
        let fields = get_repsec_fields(repsec_agr, fixskill_fields);
        getAttrs(fields, v => {
            let skills_array = [];
            _.each(repsec_agr, repsec => { skills_array.push(...repsec.ids.map(id => `repeating_${repsec.section}_${id}`)) }), skills_array.push(...pfoglobals_skill_list), v.skill_check_penalty = Math.min(parseInt(v.armor_check_penalty) || 0, parseInt(v.encumbrance_check_penalty) || 0);
            let update = calc_skill(skills_array, v, !0);
            update.skill_check_penalty = v.skill_check_penalty, setAttrs(update, { silent: !0 })
        })
    })
}, update_skill = function (skillname, sourcefield) {
    let fields = pfoglobals_skill_fields.concat([...pfoglobals_skill_attr.map(skillattr => `${skillname}_${skillattr}`)]);
    getAttrs(fields, v => { setAttrs(calc_skill([skillname], v), { silent: !0 }, () => { "ranks" == sourcefield.slice(-5) && update_skills_ranks() }) })
}, calc_skill = function (skills_array, v, update_ranks = !1) {
    let update = {}, total_ranks = 0;
    return _.each(skills_array, skillname => {
        let penlt = 0, abltmod = 0, cls = parseInt(v[`${skillname}_classkill`]) || 0, ranks = parseInt(v[`${skillname}_ranks`]) || 0;
        total_ranks += ranks, ["strength", "dexterity"].includes(v[`${skillname}_ability`]) ? "0" != v[`${skillname}_armor_penalty`] && (penlt = parseInt(v.skill_check_penalty) || 0, update[`${skillname}_armor_penalty`] = "1") : update[`${skillname}_armor_penalty`] = "0";
        let clsbonus = cls * ranks != 0 ? 3 : 0, flag = (0 != penlt ? 1 : 0) + 2 * (0 != (parseInt(v[`${skillname}_bonus`]) || 0) ? 1 : 0);
        update[`${skillname}_penalty_flag`] = flag, abltmod = parseInt(v[`${v[`${skillname}_ability`]}_mod`]) || 0, update[`${skillname}_ability_mod`] = abltmod;
        let skill = clsbonus + ranks + penlt + abltmod + (parseInt(v[`${skillname}_misc`]) || 0) + (parseInt(v[`${skillname}_bonus`]) || 0);
        "repeating_skill" == skillname.substr(0, 15) ? update[`${skillname}_skill`] = skill : update[skillname] = skill
    }), update_ranks && (update.skills_ranks_total = total_ranks), update
}, update_skills_ranks = function () {
    get_repsec_ids(JSON.parse(JSON.stringify(pfoglobals_repsec_skills)), repsec_agr => {
        let fields = get_repsec_fields(repsec_agr, [...pfoglobals_skill_list.map(skill => `${skill}_ranks`)]).filter(fld => "ranks" == fld.slice(-5));
        getAttrs(fields, v => {
            let ranks = 0;
            _.each(fields, fld => { ranks += parseInt(v[fld]) || 0 }), setAttrs({ skills_ranks_total: ranks }, { silent: !0 })
        })
    })
}, update_skillranks_total = function () { getAttrs(pfoglobals_skillranks_fields, v => { setAttrs(calc_skillranks_total(v), { silent: !0 }) }) }, calc_skillranks_total = function (v) {
    let update = {};
    for (var i = 1;
        i < 4;
        i++)update[`class${i}_skillranks_perlevel`] = Math.max((parseInt(v[`class${i}_skillranks_base`]) || 0) + (parseInt(v.intelligence_mod) || 0), 1), update[`class${i}_skillranks`] = (parseInt(update[`class${i}_skillranks_perlevel`]) || 0) * (parseInt(v[`class${i}_level`]) || 0) + (parseInt(v[`class${i}_skillranks_misc`]) || 0), update.skills_ranks_total_max = (parseInt(update.skills_ranks_total_max) || 0) + update[`class${i}_skillranks`];
    return update
}, update_speed = function () { getAttrs(pfoglobals_speed_fields, v => { setAttrs(calc_speed(v), { silent: !0 }) }) }, calc_speed = function (v) {
    let update = {}, speed_base = (parseInt(v.speed_race) || 30) + (parseInt(v.speed_class) || 0);
    update.speed_character = speed_base;
    let speed_encumbrance = speed_base;
    ["medium", "heavy"].includes(v.encumbrance) ? speed_encumbrance = calc_reduced_speed(speed_base) : "over" == v.encumbrance && (speed_encumbrance = 5), update.speed_encumbrance = speed_encumbrance, v.speed_encumbrance = speed_encumbrance, "1" != v.speed_notmodified && (speed_base = Math.min(speed_base, parseInt(v.speed_encumbrance) || 30, parseInt(v.speed_armor) || 30)), update.speed_base = speed_base, v.speed_base = speed_base;
    let runfac = Math.min(parseInt(v.encumbrance_run_factor) || 4, parseInt(v.armor_run_factor) || 4);
    update.speed_run_factor = runfac, v.speed_run_factor = runfac;
    let speed = 0, fourth = 0, run = 0;
    return "1" != v.speed_condition_nospeed && (speed = ((parseInt(v.speed_base) || 30) + (parseInt(v.speed_bonus) || 0)) * (parseFloat(v.speed_condition_multiplier) || 1), fourth = calc_round_speed(speed / 4), run = (speed = calc_round_speed(speed)) * ("1" == v.speed_condition_norun ? 0 : parseInt(v.speed_run_factor) || 4)), update.speed = speed, update.speed_run = run, update.speed_swim_base = fourth, update.speed_swim = fourth + (parseInt(v.speed_swim_misc) || 0) + (parseInt(v.speed_swim_bonus) || 0), update.speed_swim_flag = (parseInt(v.speed_bonus) || 0) + (parseInt(v.speed_swim_bonus) || 0), update.speed_climb_base = fourth, update.speed_climb = fourth + (parseInt(v.speed_climb_misc) || 0) + (parseInt(v.speed_climb_bonus) || 0), update.speed_climb_flag = (parseInt(v.speed_bonus) || 0) + (parseInt(v.speed_climb_bonus) || 0), update
}, calc_reduced_speed = function (basespeed) { return 5 * Math.ceil((parseInt(basespeed) || 30) / 5 / 3 * 2) }, calc_round_speed = function (rawspeed) {
    let speed = 5 * Math.floor((parseFloat(rawspeed) || 0) / 5);
    return speed = speed < 5 ? 5 : speed
}, update_gear_weight = function (id) {
    let fields = [`repeating_gear_${id}_weight`, `repeating_gear_${id}_quantity`];
    getAttrs(fields, v => {
        let update = {}, weight = (parseFloat(v[`repeating_gear_${id}_weight`]) || 0) * (parseFloat(v[`repeating_gear_${id}_quantity`]) || 0);
        weight - parseInt(weight) > 0 && (weight = weight.toFixed(1)), update[`repeating_gear_${id}_weight_total`] = weight, setAttrs(update, { silent: !1 })
    })
}, update_coins_weight = function () {
    getAttrs(["money_cp", "money_sp", "money_gp", "money_pp"], v => {
        let weight = ((parseInt(v.money_cp) || 0) + (parseInt(v.money_sp) || 0) + (parseInt(v.money_gp) || 0) + (parseInt(v.money_pp) || 0)) / 50;
        weight - parseInt(weight) > 0 && (weight = weight.toFixed(1)), setAttrs({ encumbrance_coins_weight: weight }, { silent: !1 })
    })
}, update_gear_weight_total = function () {
    getSectionIDs("repeating_gear", idarray => {
        let attribs = ["encumbrance_coins_weight", "encumbrance_coins_flag"];
        _.each(idarray, id => { attribs.push(`repeating_gear_${id}_weight_total`) }), getAttrs(attribs, v => {
            let total = 0;
            _.each(idarray, id => { total += parseFloat(v[`repeating_gear_${id}_weight_total`]) || 0 }), (total += (parseInt(v.encumbrance_coins_flag) || 0) * (parseFloat(v.encumbrance_coins_weight) || 0)) - parseInt(total) > 0 && (total = total.toFixed(1)), setAttrs({ encumbrance_gear_weight: total }, { silent: !1 })
        })
    })
}, update_encumbrance = function () { getAttrs(pfoglobals_encumbrance_fields, v => { "1" != v.npc && setAttrs(calc_encumbrance(v), { silent: !0 }, () => { update_speed(), update_ac_ability("encumbrance_ability_maximum"), update_all_skills() }) }) }, calc_encumbrance = function (v) {
    let update = {}, checkpen = 0, dexmax = 99, maxab = "-", runfactor = 4, display = "", weight = parseInt(v.encumbrance_gear_weight) || 0, speedbase = (parseInt(v.speed_race) || 30) + (parseInt(v.speed_class) || 0), bonus = parseInt(v.encumbrance_load_bonus) || 0, str = (parseInt(v.strength) || 10) + bonus, multi = parseFloat(v.encumbrance_load_multiplier) || 1, size = parseFloat(v.encumbrance_size) || 1, heavy = parseInt(calc_max_load(str) * size * multi), medium = Math.floor(heavy / 3 * 2), light = Math.floor(heavy / 3), prevenc = v.encumbrance, speed = speedbase, newenc = prevenc;
    return update.encumbrance_load_light = light, update.encumbrance_load_medium = medium, update.encumbrance_load_heavy = heavy, update.encumbrance_lift_head = heavy, update.encumbrance_lift_ground = 2 * heavy, update.encumbrance_drag_push = 5 * heavy, v.encumbrance_display && (display = v.encumbrance_display), weight > light && weight <= medium ? (newenc = "medium", checkpen = -3, speed = calc_reduced_speed(speedbase), dexmax = 3, runfactor = 4) : weight > medium && weight <= heavy ? (newenc = "heavy", checkpen = -6, speed = calc_reduced_speed(speedbase), dexmax = 1, runfactor = 3) : weight > heavy ? (newenc = "over", checkpen = -6, speed = 5, dexmax = 1, runfactor = 3) : newenc = "light", prevenc == newenc && "" != display || (dexmax < 99 && (maxab = dexmax), update.encumbrance = newenc, update.encumbrance_display = getTranslationByKey(`${newenc}-load`), update.encumbrance_check_penalty = checkpen, update.speed_encumbrance = speed, update.encumbrance_ability_maximum = maxab, update.encumbrance_run_factor = runfactor), update
}, calc_max_load = function (str) { return str >= 0 && str <= 10 ? 10 * str : str > 14 ? 2 * calc_max_load(str - 5) : [115, 130, 150, 175][str - 11] }, update_concentration = function (srcattr) {
    let cster = srcattr.substr(0, 7).slice(-1);
    getAttrs(pfoglobals_concentration_fields, v => { "1" != v.npc && setAttrs(calc_concentration(srcattr, v), { silent: !0 }, () => { srcattr == `caster${cster}_ability` && update_spells_dc(srcattr) }) })
}, calc_concentration = function (srcattr, v) {
    let update = {}, cster = srcattr.substr(0, 7).slice(-1);
    return srcattr == `caster${cster}_ability` && (update[`caster${cster}_ability_mod`] = parseInt(v[`${v[`caster${cster}_ability`]}_mod`]) || 0, v[`caster${cster}_ability_mod`] = update[`caster${cster}_ability_mod`]), update[`caster${cster}_concentration`] = (parseInt(v[`caster${cster}_level`]) || 0) + (parseInt(v[`caster${cster}_ability_mod`]) || 0) + (parseInt(v[`caster${cster}_concentration_misc`]) || 0) + (parseInt(v[`caster${cster}_concentration_bonus`]) || 0), update
}, update_spells_dc = function (attr) {
    let minlvl = 0, maxlvl = 0, update_all = !1;
    ["caster1_ability", "caster1_ability_mod", "caster1_dc_misc", "caster2_ability", "caster2_ability_mod", "caster2_dc_misc"].includes(attr) ? (update_all = !0, maxlvl = 10) : (minlvl = parseInt(attr.slice(-1)) || 0, maxlvl = 1 + minlvl), minlvl >= 0 && maxlvl <= 10 && getAttrs(pfoglobals_spells_dc_fields, v => {
        if ("1" != v.npc) {
            let update = calc_spells_dc(attr, v, minlvl, maxlvl);
            update_all ? setAttrs(update, { silent: !0 }, () => { update_all_spells("all") }) : setAttrs(update, { silent: !1 })
        }
    })
}, calc_spells_dc = function (attr, v, minlvl, maxlvl) {
    var cster = attr.substr(0, 7).slice(-1), update = {}, i = 0;
    for (attr == `caster${cster}_ability` && (update[`caster${cster}_ability_mod`] = parseInt(v[`${v[`caster${cster}_ability`]}_mod`]) || 0, v[`caster${cster}_ability_mod`] = update[`caster${cster}_ability_mod`]), i = minlvl;
        i < maxlvl;
        i++)update[`caster${cster}_dc_level_${i}`] = 10 + i + (parseInt(v[`caster${cster}_ability_mod`]) || 0) + (parseInt(v[`caster${cster}_dc_misc`]) || 0) + (parseInt(v[`caster${cster}_dcbonus_level_${i}`]) || 0);
    return update
}, update_spells_flag = function (level) {
    getAttrs([`caster1_spells_known_level_${level}`, `caster2_spells_known_level_${level}`, `caster1_spells_total_level_${level}`, `caster2_spells_total_level_${level}`], v => {
        let update = {}, tot = (parseInt(v[`caster1_spells_known_level_${level}`]) || 0) + (parseInt(v[`caster2_spells_known_level_${level}`]) || 0) + (parseInt(v[`caster1_spells_total_level_${level}`]) || 0) + (parseInt(v[`caster2_spells_total_level_${level}`]) || 0);
        update[`caster_spells_flag_level_${level}`] = tot > 0 ? 1 : 0, setAttrs(update)
    })
}, update_spells_totals = function (level, cster) {
    getAttrs([`caster${cster}_spells_perday_level_${level}`, `caster${cster}_spells_bonus_level_${level}`], v => {
        let update = {};
        update[`caster${cster}_spells_total_level_${level}`] = (parseInt(v[`caster${cster}_spells_perday_level_${level}`]) || 0) + (parseInt(v[`caster${cster}_spells_bonus_level_${level}`]) || 0), setAttrs(update, { silent: !1 })
    })
}, update_spells_prepared = function (src, val) {
    let update = {}, repsec = src.substr(0, 17), level = repsec.charAt(repsec.length - 1);
    getSectionIDs(`repeating_spell-${level}`, idarray => {
        let spell_attribs = [`caster1_spells_total_level_${level}`, `caster2_spells_total_level_${level}`];
        spell_attribs.push(...idarray.map(spellid => `repeating_spell-${level}_${spellid}_spellprepared`), ...idarray.map(spellid => `repeating_spell-${level}_${spellid}_spellcaster`)), getAttrs(spell_attribs, v => {
            let total1 = 0, total2 = 0;
            _.each(idarray, id => { "2" == v[`repeating_spell-${level}_${id}_spellcaster`] ? total2 += parseInt(v[`repeating_spell-${level}_${id}_spellprepared`]) || 0 : total1 += parseInt(v[`repeating_spell-${level}_${id}_spellprepared`]) || 0 }), update[`caster1_spells_prepared_level_${level}`] = total1, update[`caster1_spells_prepared_flag_${level}`] = total1 > (parseInt(v[`caster1_spells_total_level_${level}`]) || 0) ? 1 : 0, update[`caster2_spells_prepared_level_${level}`] = total2, update[`caster2_spells_prepared_flag_${level}`] = total2 > (parseInt(v[`caster2_spells_total_level_${level}`]) || 0) ? 1 : 0, setAttrs(update, { silent: !0 })
        })
    })
}, update_all_spells = function (update_id) { get_repsec_ids(JSON.parse(JSON.stringify(pfoglobals_repsec_spell)), repsec_agr => { do_update_spell(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "like"], update_id, repsec_agr) }) }, update_spells = function (level, update_id) {
    let attr_array = [];
    attr_array = "like" == level ? pfoglobals_spell_attr.concat(pfoglobals_spell_like_attr) : pfoglobals_spell_attr.concat(pfoglobals_spell_only_attr), "-" === update_id.substring(0, 1) && 20 === update_id.length ? do_update_spell([level], "", [{ section: `spell-${level}`, ids: [update_id], attrs: attr_array }]) : ["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma", "melee", "ranged", "cmb", "all"].includes(update_id) && get_repsec_ids([{ section: "spell-" + level, attrs: attr_array }], repsec_agr => { do_update_spell([level], update_id, repsec_agr) })
}, do_update_spell = function (level, attributename = "", repsec_agr) {
    let spell_attribs = get_repsec_fields(repsec_agr, pfoglobals_spell_fields);
    spell_attribs = spell_attribs.concat(["level"], pfoglobals_babs_fields, pfoglobals_abilities), getAttrs(spell_attribs, v => { setAttrs(calc_spells(level, repsec_agr, v, attributename), { silent: !0 }) })
}, calc_spells = function (level, repsec_agr, v, attributename = "") {
    let update = {};
    return _.each(level, spell_level => {
        let repsec = repsec_agr.find(repsec => repsec.section === "spell-" + spell_level);
        repsec && repsec.ids && _.each(repsec.ids, spellid => { (0 === attributename.length || "all" == attributename || v["repeating_spell-" + spell_level + "_" + spellid + "_spellatktype"] && v["repeating_spell-" + spell_level + "_" + spellid + "_spellatktype"].includes(attributename)) && _.extend(update, calc_spell(spell_level, spellid, v)) })
    }), update
}, calc_spell = function (spell_level, spellid, v) {
    let update = {}, stemp = "", rollbase = "", rollbasetemplate = "pc", conditionsnote = "";
    "npc" in v && "1" == v.npc && (rollbasetemplate = "npc");
    let atkflag = v[`repeating_spell-${spell_level}_${spellid}_spellatkflag`] || "0", atktype = v[`repeating_spell-${spell_level}_${spellid}_spellatktype`] || "0", atkmod = v[`repeating_spell-${spell_level}_${spellid}_spellatkmod`] || "0", atkcritrange = parseInt(v[`repeating_spell-${spell_level}_${spellid}_spellatkcritrange`]) || 20, dmgflag = v[`repeating_spell-${spell_level}_${spellid}_spelldmgflag`] || "0", dmgbase = v[`repeating_spell-${spell_level}_${spellid}_spelldmg`] || "0";
    dmgbase.length || (dmgbase = "0");
    let dmgcritmulti = parseInt(v[`repeating_spell-${spell_level}_${spellid}_spelldmgcritmulti`]) || 1, dmgtype = v[`repeating_spell-${spell_level}_${spellid}_spelldmgtype`] || "", dmg2flag = v[`repeating_spell-${spell_level}_${spellid}_spelldmg2flag`] || "0", dmg2name = v[`repeating_spell-${spell_level}_${spellid}_spelldmg2name`] || getTranslationByKey("damage2"), dmg2base = v[`repeating_spell-${spell_level}_${spellid}_spelldmg2`] || "0";
    dmg2base.length || (dmg2base = "0");
    let dmg2type = v[`repeating_spell-${spell_level}_${spellid}_spelldmg2type`] || "", cster = v[`repeating_spell-${spell_level}_${spellid}_spellcaster`] || "1", csterflag1 = v.caster1_flag || "0", csterflag2 = v.caster2_flag || "0";
    "like" == spell_level ? ("1" != v.npc && v[`repeating_spell-${spell_level}_${spellid}_timesperday`] && ["per-hour", "per-day", "per-week", "per-month", "per-year"].includes(v[`repeating_spell-${spell_level}_${spellid}_timesperday`] || "at-will") && (update[`repeating_spell-${spell_level}_${spellid}_perday_max`] = parse_formula("" + (v[`repeating_spell-${spell_level}_${spellid}_perday_qty`] || "1"), v), v[`repeating_spell-${spell_level}_${spellid}_perday_max`] = update[`repeating_spell-${spell_level}_${spellid}_perday_max`]), v[`repeating_spell-${spell_level}_${spellid}_timesperday`] && "every-hours" == v[`repeating_spell-${spell_level}_${spellid}_timesperday`] ? (update[`repeating_spell-${spell_level}_${spellid}_spelldisplay`] = v[`repeating_spell-${spell_level}_${spellid}_spellname`] + " — " + pfoglobals_i18n_obj["every-hours"].replace("X", v[`repeating_spell-${spell_level}_${spellid}_perday_max`] || "1"), update[`repeating_spell-${spell_level}_${spellid}_spellprepared`] = 0) : (update[`repeating_spell-${spell_level}_${spellid}_spelldisplay`] = v[`repeating_spell-${spell_level}_${spellid}_spellname`] + " — " + pfoglobals_i18n_obj[v[`repeating_spell-${spell_level}_${spellid}_timesperday`] || "at-will"], ["per-hour", "per-day", "per-week", "per-month", "per-year"].includes(v[`repeating_spell-${spell_level}_${spellid}_timesperday`] || "at-will") ? update[`repeating_spell-${spell_level}_${spellid}_spellprepared`] = 1 : update[`repeating_spell-${spell_level}_${spellid}_spellprepared`] = 0)) : (update[`repeating_spell-${spell_level}_${spellid}_spelldisplay`] = v[`repeating_spell-${spell_level}_${spellid}_spellname`] || "???", "1" == csterflag1 && v.caster1_class ? update[`repeating_spell-${spell_level}_${spellid}_spellcaster1_class`] = v.caster1_class.length > 0 ? v.caster1_class : " " : update[`repeating_spell-${spell_level}_${spellid}_spellcaster1_class`] = " ", "1" == csterflag2 && v.caster2_class ? update[`repeating_spell-${spell_level}_${spellid}_spellcaster2_class`] = v.caster2_class.length > 0 ? v.caster2_class : " " : update[`repeating_spell-${spell_level}_${spellid}_spellcaster2_class`] = " ", "1" == csterflag1 && "1" == csterflag2 ? update[`repeating_spell-${spell_level}_${spellid}_spellmulticasters-flag`] = 1 : (update[`repeating_spell-${spell_level}_${spellid}_spellmulticasters-flag`] = 0, "1" == csterflag1 ? (update[`repeating_spell-${spell_level}_${spellid}_spellcaster`] = 1, cster = "1") : "1" == csterflag2 && (update[`repeating_spell-${spell_level}_${spellid}_spellcaster`] = 2, cster = "2")));
    let savedc = 0;
    if ("npc" in v && "1" != v.npc ? savedc += (parseInt(v[`caster${cster}_dc_level_${spell_level}`]) || 0) + parse_formula(v[`repeating_spell-${spell_level}_${spellid}_spelldc_mod`] || "", v) : savedc += parseInt(v[`repeating_spell-${spell_level}_${spellid}_spelldc_mod`]) || 0, rollbase = `@{whispertype} &{template:${rollbasetemplate}}{{name=${v[`repeating_spell-${spell_level}_${spellid}_spellname`]}}}{{type=spell}}{{showchar=@{rollshowchar}}}{{charname=@{character_name}}}{{nonlethal=[[1[Nonlethal]]]}}`, "like" == spell_level ? "npc" in v && "1" == v.npc && (rollbase += `{{level=${v.caster2_level}}}`) : rollbase += `{{level=${spell_level}}}`, "1" != (v.npc || "0") && "1" == csterflag1 && "1" == csterflag2 && v.caster1_class && v.caster2_class && "like" != spell_level && (rollbase += `{{casterclass=${"1" == cster ? v.caster1_class : v.caster2_class}}}`), "like" == spell_level && v[`repeating_spell-${spell_level}_${spellid}_spelltype`] && (rollbase += `{{powertype=${v[`repeating_spell-${spell_level}_${spellid}_spelltype`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spellschool`] && (rollbase += `{{school=${v[`repeating_spell-${spell_level}_${spellid}_spellschool`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spellcastingtime`] && (rollbase += `{{castingtime=${v[`repeating_spell-${spell_level}_${spellid}_spellcastingtime`]}}}`), "like" != spell_level && v[`repeating_spell-${spell_level}_${spellid}_spellcomponent`] && (rollbase += `{{component=${v[`repeating_spell-${spell_level}_${spellid}_spellcomponent`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spellrange`] && (rollbase += `{{range=${v[`repeating_spell-${spell_level}_${spellid}_spellrange`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spellarea`] && (rollbase += `{{area=${v[`repeating_spell-${spell_level}_${spellid}_spellarea`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spelltargets`] && (rollbase += `{{targets=${v[`repeating_spell-${spell_level}_${spellid}_spelltargets`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spelleffect`] && (rollbase += `{{effect=${v[`repeating_spell-${spell_level}_${spellid}_spelleffect`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spellduration`] && (rollbase += `{{duration=${v[`repeating_spell-${spell_level}_${spellid}_spellduration`]}}}`), v[`repeating_spell-${spell_level}_${spellid}_spellsaveflag`] && "0" != v[`repeating_spell-${spell_level}_${spellid}_spellsaveflag`] && (rollbase += `{{save=1}} {{savedc=[[${savedc}]]}}{{saveeffect=${v[`repeating_spell-${spell_level}_${spellid}_spellsave`] || ""}}}`), v[`repeating_spell-${spell_level}_${spellid}_spellresistanceflag`] && "0" != v[`repeating_spell-${spell_level}_${spellid}_spellresistanceflag`] && (rollbase += `{{sr=1}} {{spellresistance=${v[`repeating_spell-${spell_level}_${spellid}_spellresistance`] || ""}}}`), v[`repeating_spell-${spell_level}_${spellid}_spelldescflag`] && "0" != v[`repeating_spell-${spell_level}_${spellid}_spelldescflag`] && (rollbase += `{{descflag=[[1]]}} {{desc=${v[`repeating_spell-${spell_level}_${spellid}_spelldesc`] || ""}}}`), "0" != atkflag && ("0" != atktype && (atktype = "@{" + atktype + "_mod}"), 0 == atkmod.length && (atkmod = "0"), rollbase += atkflag + "{{roll=[[1d20cs>" + atkcritrange + "+" + atktype + "[" + pfoglobals_i18n_obj[v["repeating_spell-${spell_level}_${spellid}_spellatktype"] || "0"] + "]+" + atkmod + "[MOD]+(@{attack_bonus})[TEMP]+(@{attack_condition})[CONDITION]+@{rollmod_attack}[QUERY]]]}}", rollbase += "{{critconfirm=[[1d20cs20+" + atktype + "[" + pfoglobals_i18n_obj[v["repeating_spell-${spell_level}_${spellid}_spellatktype"] || "0"] + "]+" + atkmod + "[MOD]+(@{attack_bonus})[TEMP]+(@{attack_condition})[CONDITION]+@{rollmod_attack}[QUERY]+@{critconfirm_bonus}[CRIT CONFIRM BONUS]]]}}", v.npc && "1" != v.npc && (conditionsnote += "@{attack_condition_note}", rollbase += "{{conditionsflag=[[@{attack_condition}]]}}{{conditions=@{conditions_display}}}")), "0" != dmgflag || "0" != dmg2flag) {
        if ("0" != dmgflag && (rollbase += `${dmgflag} {{dmg1=[[${stemp = `${dmgbase} + @{damage_bonus}[TEMP] + @{rollmod_damage}[QUERY]`}]]}} {{dmg1type=${dmgtype}}}`, "0" != atkflag && dmgcritmulti > 1)) {
            for (stemp = "", i = 1;
                i <= dmgcritmulti;
                i++)stemp += `${stemp.length > 0 ? " + " : ""}${dmgbase}`;
            rollbase += `{{dmg1crit=[[(${stemp}) + (@{rollmod_damage} * ${dmgcritmulti})[QUERY]]]}}`
        } if ("0" != dmg2flag && (rollbase += `{{dmg2name=${dmg2name}}}`, rollbase += `${dmg2flag} {{dmg2=[[${stemp = `${dmg2base} + @{damage_bonus}[TEMP] + @{rollmod_damage}[QUERY]`}]]}} {{dmg2type=${dmg2type}}}`, "0" != atkflag && dmgcritmulti > 1)) {
            for (stemp = "", i = 1;
                i <= dmgcritmulti;
                i++)stemp += `${stemp.length > 0 ? " + " : ""}${dmg2base}`;
            rollbase += `{{dmg2crit=[[(${stemp}) + (@{rollmod_damage} * ${dmgcritmulti})[QUERY]]]}}`
        }
    } return "1" != (v.npc || "0") && "like" != spell_level && "0" != (v.armor_spell_failure || "0") && ("1" == (v.caster1_spell_failure || "1") && "1" == cster || "2" == cster && "1" == (v.caster2_spell_failure || "1")) && (rollbase += "{{spellfailureroll=[[1d100]]}}", rollbase += `{{spellfailure=[[${v.armor_spell_failure}]]}}`, conditionsnote += "@{spell_condition_note}"), "1" != (v.npc || "0") && "like" != spell_level && v[`caster${cster}_concentration_roll`] && (update[`repeating_spell-${spell_level}_${spellid}_rollconcentration`] = v[`caster${cster}_concentration_roll`], rollbase += `{{concentration=[${getTranslationByKey("concentration")}](~repeating_spell-${spell_level}_concentration)}}`), "1" != (v.npc || "0") && (v.rollnotes_spell && "0" != v.rollnotes_spell && v[`repeating_spell-${spell_level}_${spellid}_notes`] && (rollbase += `{{shownotes=[[1]]}}{{notes=${v[`repeating_spell-${spell_level}_${spellid}_notes`] || ""}}}`), rollbase += `{{conditionsnote=${conditionsnote}}}`), update[`repeating_spell-${spell_level}_${spellid}_spelldc`] = savedc, update[`repeating_spell-${spell_level}_${spellid}_rollcontent`] = rollbase, update
}, calc_conditions = function (v, reset = !1) {
    let dspl = "", update = {}, strength_condition = 0, dexterity_condition = 0, dexterity_condition_nobonus = 0, ability_check_condition = 0, ac_condition = 0, ac_condition_nobonus = 0, ac_condition_note = " ", cmd_condition = 0, skill_condition = 0, skill_condition_note = "", perception_condition_note = "", attack_condition = 0, attack_condition_note = "", cmb_condition_note = "", damage_condition_note = "", initiative_condition = 0, spell_condition_note = "", saves_condition = 0, hp_condition = 0, speed_condition = 0, speed_condition_multiplier = 1, speed_condition_nospeed = 0, speed_condition_norun = 0, i = 0;
    return reset ? (_.each(pfoglobals_conditions, fld => { update[fld] = 0 }), update["options-flag-conditions"] = 0) : _.each(pfoglobals_conditions, fld => { (parseInt(v[fld]) || 0) > 0 && (dspl += (dspl.trim().length ? " • " : "") + pfoglobals_i18n_obj[fld.replace("condition_", "")], "condition_blinded" == fld && (ac_condition -= 2, cmd_condition -= 2, ac_condition_nobonus = 1, skill_condition_note += getTranslationByKey("blinded-skills") + " ", perception_condition_note += getTranslationByKey("blinded-perception") + " "), "condition_cowering" == fld && (ac_condition -= 2, cmd_condition -= 2, ac_condition_nobonus = 1), "condition_dazzled" == fld && (perception_condition_note += getTranslationByKey("dazzled-perception") + " ", attack_condition -= 1), "condition_deafened" == fld && (perception_condition_note += getTranslationByKey("deafened-perception") + " ", initiative_condition -= 4, spell_condition_note += getTranslationByKey("deafened-spell") + " "), "condition_energy_drained" == fld && (i = parseInt(v.condition_energy_drained) || 1, dspl += " (" + i + ")", ability_check_condition -= i, initiative_condition -= i, cmd_condition -= i, skill_condition -= i, attack_condition -= i, saves_condition -= i, hp_condition -= 5 * i), "condition_entangled" == fld && (dexterity_condition -= 4, attack_condition -= 2, speed_condition = 1, speed_condition_multiplier = Math.min(speed_condition_multiplier, .5), speed_condition_norun = 1), "condition_exhausted" == fld && (strength_condition -= 6, dexterity_condition -= 6, speed_condition = 1, speed_condition_multiplier = Math.min(speed_condition_multiplier, .5), speed_condition_norun = 1), "condition_fascinated" == fld && (skill_condition_note += getTranslationByKey("fascinated-skills") + " "), "condition_fatigued" == fld && (strength_condition -= 2, dexterity_condition -= 2), "condition_frightened" == fld && (ability_check_condition -= 2, skill_condition -= 2, attack_condition -= 2, initiative_condition -= 2, saves_condition -= 2), "condition_grappled" == fld && (dexterity_condition -= 4, attack_condition -= 2, cmb_condition_note += getTranslationByKey("grappled-cmb") + " ", speed_condition = 1, speed_condition_nospeed = 1), "condition_invisible" == fld && (attack_condition_note += getTranslationByKey("invisible-attack") + " "), "condition_panicked" == fld && (ability_check_condition -= 2, skill_condition -= 2, initiative_condition -= 2, saves_condition -= 2), "condition_pinned" == fld && (dexterity_condition_nobonus = 1, ac_condition_nobonus = 1, ac_condition -= 4, cmd_condition -= 4, speed_condition = 1, speed_condition_nospeed = 1), "condition_prone" == fld && (ac_condition_note += getTranslationByKey("prone-defender") + " ", attack_condition_note += getTranslationByKey("prone-attacker") + " "), "condition_shaken" == fld && (ability_check_condition -= 2, skill_condition -= 2, attack_condition -= 2, initiative_condition -= 2, saves_condition -= 2), "condition_sickened" == fld && (ability_check_condition -= 2, skill_condition -= 2, attack_condition -= 2, damage_condition_note += getTranslationByKey("sickened-damage") + " ", initiative_condition -= 2, saves_condition -= 2), "condition_stunned" == fld && (ac_condition -= 2, cmd_condition -= 2, ac_condition_nobonus = 1)) }), update.strength_condition = strength_condition, update.dexterity_condition = dexterity_condition, update.ability_check_condition = ability_check_condition, update.dexterity_condition_nobonus = dexterity_condition_nobonus, update.ac_condition = ac_condition, update.ac_condition_nobonus = ac_condition_nobonus, update.ac_condition_note = ac_condition_note, update.cmd_condition = cmd_condition, update.skill_condition = skill_condition, update.skill_condition_note = skill_condition_note, update.perception_condition_note = perception_condition_note, update.attack_condition = attack_condition, update.attack_condition_note = attack_condition_note, update.cmb_condition_note = cmb_condition_note, update.damage_condition_note = damage_condition_note, update.initiative_condition = initiative_condition, update.spell_condition_note = spell_condition_note, update.saves_condition = saves_condition, update.hp_condition = hp_condition, update.speed_condition = speed_condition, update.speed_condition_multiplier = speed_condition_multiplier, update.speed_condition_nospeed = speed_condition_nospeed, update.speed_condition_norun = speed_condition_norun, update.conditions_display = dspl.trim().length ? dspl.trim() : " ", update
}, calc_buffs = function (repsec_agr, v, reset = !1, skills_array = []) {
    let buffables = { ac_armor_bonus: ["ac_armor_bonus", "ac_armor", "armor", "armor ac"], ac_bonus: ["ac_bonus", "ac", "armor class"], ac_deflection_bonus: ["ac_deflection_bonus", "deflection", "ac_deflection", "deflection ac"], ac_dodge_bonus: ["ac_dodge_bonus", "dodge", "ac_dodge", "dodge ac"], ac_natural_bonus: ["ac_natural_bonus", "natural", "ac_natural", "natural ac"], ac_shield_bonus: ["ac_shield_bonus", "shield", "ac_shield", "shield ac"], acrobatics_bonus: ["acrobatics_bonus", "acrobatics", "skill", "skills"], appraise_bonus: ["appraise_bonus", "appraise", "skill", "skills"], attack_bonus: ["attack_bonus", "attack", "attacks"], bluff_bonus: ["bluff_bonus", "bluff", "skill", "skills"], caster1_concentration_bonus: ["caster1_concentration_bonus", "concentration"], caster1_dcbonus_level_0: ["caster1_dcbonus_level_0", "dc"], caster1_dcbonus_level_1: ["caster1_dcbonus_level_1", "dc"], caster1_dcbonus_level_2: ["caster1_dcbonus_level_2", "dc"], caster1_dcbonus_level_3: ["caster1_dcbonus_level_3", "dc"], caster1_dcbonus_level_4: ["caster1_dcbonus_level_4", "dc"], caster1_dcbonus_level_5: ["caster1_dcbonus_level_5", "dc"], caster1_dcbonus_level_6: ["caster1_dcbonus_level_6", "dc"], caster1_dcbonus_level_7: ["caster1_dcbonus_level_7", "dc"], caster1_dcbonus_level_8: ["caster1_dcbonus_level_8", "dc"], caster1_dcbonus_level_9: ["caster1_dcbonus_level_9", "dc"], caster2_concentration_bonus: ["caster2_concentration_bonus", "concentration"], caster2_dcbonus_level_0: ["caster2_dcbonus_level_0", "dc"], caster2_dcbonus_level_1: ["caster2_dcbonus_level_1", "dc"], caster2_dcbonus_level_2: ["caster2_dcbonus_level_2", "dc"], caster2_dcbonus_level_3: ["caster2_dcbonus_level_3", "dc"], caster2_dcbonus_level_4: ["caster2_dcbonus_level_4", "dc"], caster2_dcbonus_level_5: ["caster2_dcbonus_level_5", "dc"], caster2_dcbonus_level_6: ["caster2_dcbonus_level_6", "dc"], caster2_dcbonus_level_7: ["caster2_dcbonus_level_7", "dc"], caster2_dcbonus_level_8: ["caster2_dcbonus_level_8", "dc"], caster2_dcbonus_level_9: ["caster2_dcbonus_level_9", "dc"], charisma_bonus: ["charisma_bonus", "charisma", "cha"], climb_bonus: ["climb_bonus", "climb", "skill", "skills"], cmb_bonus: ["cmb_bonus", "cmb"], cmd_bonus: ["cmd_bonus", "cmd"], constitution_bonus: ["constitution_bonus", "constitution", "con"], craft_bonus: ["craft_bonus", "craft", "skill", "skills"], dexterity_bonus: ["dexterity_bonus", "dexterity", "dex"], diplomacy_bonus: ["diplomacy_bonus", "diplomacy", "skill", "skills"], disable_device_bonus: ["disable_device_bonus", "disabledevice", "disable device", "skill", "skills"], disguise_bonus: ["disguise_bonus", "disguise", "skill", "skills"], encumbrance_load_bonus: ["encumbrance_load_bonus", "encumbrance"], escape_artist_bonus: ["escape_artist_bonus", "escapeartist", "escape artist", "skill", "skills"], fly_bonus: ["fly_bonus", "fly", "skill", "skills"], fortitude_bonus: ["fortitude_bonus", "fortitude", "fort", "saves", "saving throws"], handle_animal_bonus: ["handle_animal_bonus", "handleanimal", "handle animal", "skill", "skills"], heal_bonus: ["heal_bonus", "heal", "skill", "skills"], hp_bonus: ["hp_bonus", "hp", "hit points"], hp_temp: ["hp_temp", "temp hp", "temp hits points", "temporary hp", "temporary hit points"], initiative_bonus: ["initiative_bonus", "initiative", "init"], intelligence_bonus: ["intelligence_bonus", "intelligence", "int"], intimidate_bonus: ["intimidate_bonus", "intimidate", "skill", "skills"], knowledge_arcana_bonus: ["knowledge_arcana_bonus", "knowledge(arcana)", "knowledgearcana", "knowledge (arcana)", "knowledge arcana", "arcana", "knowledge", "skill", "skills"], knowledge_dungeoneering_bonus: ["knowledge_dungeoneering_bonus", "knowledge(dungeoneering)", "knowledgedungeoneering", "knowledge (dungeoneering)", "knowledge dungeoneering", "dungeoneering", "knowledge", "skill", "skills"], knowledge_engineering_bonus: ["knowledge_engineering_bonus", "knowledge(engineering)", "knowledgeengineering", "knowledge (engineering)", "knowledge engineering", "engineering", "knowledge", "skill", "skills"], knowledge_geography_bonus: ["knowledge_geography_bonus", "knowledge(geography)", "knowledgegeography", "knowledge (geography)", "knowledge geography", "geography", "knowledge", "skill", "skills"], knowledge_history_bonus: ["knowledge_history_bonus", "knowledge(history)", "knowledgehistory", "knowledge (history)", "knowledge history", "history", "knowledge", "skill", "skills"], knowledge_local_bonus: ["knowledge_local_bonus", "knowledge(local)", "knowledgelocal", "knowledge (local)", "knowledge local", "local", "knowledge", "skill", "skills"], knowledge_nature_bonus: ["knowledge_nature_bonus", "knowledge(nature)", "knowledgenature", "knowledge (nature)", "knowledge nature", "nature", "knowledge", "skill", "skills"], knowledge_nobility_bonus: ["knowledge_nobility_bonus", "knowledge(nobility)", "knowledgenobility", "knowledge (nobility)", "knowledge nobility", "nobility", "knowledge", "skill", "skills"], knowledge_planes_bonus: ["knowledge_planes_bonus", "knowledge(planes)", "knowledgeplanes", "knowledge (planes)", "knowledge planes", "planes", "knowledge", "skill", "skills"], knowledge_religion_bonus: ["knowledge_religion_bonus", "knowledge(religion)", "knowledgereligion", "knowledge (religion)", "knowledge religion", "religion", "knowledge", "skill", "skills"], linguistics_bonus: ["linguistics_bonus", "linguistics", "skill", "skills"], melee_bonus: ["melee_bonus", "melee"], perception_bonus: ["perception_bonus", "perception", "skill", "skills"], perform_bonus: ["perform_bonus", "perform", "skill", "skills"], profession_bonus: ["profession_bonus", "profession", "skill", "skills"], ranged_bonus: ["ranged_bonus", "ranged"], reflex_bonus: ["reflex_bonus", "reflex", "ref", "saves", "saving throws"], ride_bonus: ["ride_bonus", "ride", "skill", "skills"], sense_motive_bonus: ["sense_motive_bonus", "sensemotive", "sense motive", "skill", "skills"], sleight_of_hand_bonus: ["sleight_of_hand_bonus", "sleightofhand", "sleight of hand", "skill", "skills"], speed_bonus: ["speed_bonus", "speed"], speed_climb_bonus: ["speed_climb_bonus", "speed climb", "climb speed"], speed_swim_bonus: ["speed_swim_bonus", "speed swim", "swim speed"], spellcraft_bonus: ["spellcraft_bonus", "spellcraft", "skill", "skills"], stealth_bonus: ["stealth_bonus", "stealth", "skill", "skills"], strength_bonus: ["strength_bonus", "strength", "str"], survival_bonus: ["survival_bonus", "survival", "skill", "skills"], swim_bonus: ["swim_bonus", "swim", "skill", "skills"], use_magic_device_bonus: ["use_magic_device_bonus", "usemagicdevice", "use magic device", "skill", "skills"], will_bonus: ["will_bonus", "will", "saves", "saving throws"], wisdom_bonus: ["wisdom_bonus", "wisdom", "wis"], sr_bonus: ["sr_bonus", "sr", "spell resistance", "spell_resistance"], damage_bonus: ["damage_bonus", "damage", "damages"], melee_damage_bonus: ["melee_damage_bonus", "melee damage"], ranged_damage_bonus: ["ranged_damage_bonus", "ranged damage"] };
    skills_array.length && _.each(skills_array, repsk => { buffables[`${repsk}_bonus`] = [`${repsk}_bonus`, "skill", "skills", repsk.match(/repeating\_skill[^\_]+/i)[0].replace("repeating_skill", "")] });
    let update = {}, dspl = "", toggled = [], bytype = {};
    return _.each(repsec_agr, current_section => {
        _.each(current_section.ids, buffid => {
            reset ? update[`repeating_buff_${buffid}_toggle`] = "0" : v[`repeating_buff_${buffid}_toggle`] && "1" == v[`repeating_buff_${buffid}_toggle`] && (dspl += `${dspl.trim().length ? " • " : ""}${v[`repeating_buff_${buffid}_name`] || "???"}`), v[`repeating_buff_${buffid}_mods`] && v[`repeating_buff_${buffid}_mods`].trim().length && (update[`repeating_buff_${buffid}_showmods`] = v[`repeating_buff_${buffid}_mods`].replace(/\{/g, "&#123;
").replace(/\}/g, " &#125;
            "), toggled = toggled.concat(...v[`repeating_buff_${buffid}_mods`].trim().toLowerCase().split(/[\n|\;
]/g).map(str => { let strParts = str.match(/((?: \+|\-)?.*? (?= (?: [a - z\s] +) ?\s + to\s +))(?: \s + ([a - z\s] +)) ? (?: \s + to\s +) ([^;
        \n$] +) / i);
    if (strParts && strParts[1] && strParts[3]) {
        let formula = "", type = "", tmpstat = "", objarray = [];
        return formula = reset || !v[`repeating_buff_${buffid}_toggle`] || v[`repeating_buff_${buffid}_toggle`] && "1" != v[`repeating_buff_${buffid}_toggle`] ? 0 : parse_formula(strParts[1], v), type = strParts[2] || "untyped", (tmpstat = strParts[3]) in buffables ? objarray.push({ stat: tmpstat, value: formula, type: type }) : _.each(Object.keys(buffables), key => { buffables[key].includes(tmpstat) && objarray.push({ stat: key, value: formula, type: type }) }), objarray
    }
}).filter(x => null != x))) }) }), toggled.length && (_.each(toggled, buff => { "ac_bonus" == buff.stat && ["dodge", "armor", "shield", "natural", "deflection"].includes(buff.type) && (buff.stat = `ac_${buff.type}_bonus`, buff.type = "untyped"), bytype[buff.stat] || (bytype[buff.stat] = {}), bytype[buff.stat][buff.type] || (["dodge", "untyped", "circumstance"].includes(buff.type) ? bytype[buff.stat][buff.type] = 0 : bytype[buff.stat][buff.type] = -999), ["dodge", "untyped", "circumstance"].includes(buff.type) ? bytype[buff.stat][buff.type] += parseInt(buff.value) || 0 : bytype[buff.stat][buff.type] = Math.max(parseInt(bytype[buff.stat][buff.type]) || 0, parseInt(buff.value) || 0) }), _.each(Object.keys(bytype), buff => { update[buff] = Object.values(bytype[buff]).reduce((a, b) => a + b, 0) })), "hp_temp" in update && (update.hp_temp = Math.max(parseInt(v.hp_temp) || 0, parseInt(update.hp_temp) || 0)), reset && (update["options-flag-conditions"] = 0), update.buffs_display = dspl.trim().length ? dspl.trim() : " ", update }, le_big_stuff = function (ability, objoptions = {}, callback = null) {
    let debug_start = new Date, all_repsecs = [...pfoglobals_repsec_atk, ...pfoglobals_repsec_spell, ...pfoglobals_repsec_skills, ...pfoglobals_repsec_buff, ...pfoglobals_repsec_traits];
    get_repsec_ids(JSON.parse(JSON.stringify(all_repsecs)), repsec_agr => {
        let tmpfields = [];
        tmpfields.push("size", "level", "hp_base", "hp_base_max", "hp_condition", "hp_bonus", "hp_temp", "dexterity_condition_nobonus", "sr_base", "sr_bonus"), _.each(["fortitude", "reflex", "will"], savename => { tmpfields.push(...pfoglobals_save_attr.map(fld => `${savename}_${fld}`)) }), _.each(pfoglobals_skill_list, skillname => { tmpfields.push(...pfoglobals_skill_attr.map(skillattr => skillname + "_" + skillattr)) }), tmpfields.push(...pfoglobals_skillranks_fields), tmpfields.push(...pfoglobals_abilities, ...pfoglobals_abilities_fields, ...pfoglobals_mods, ...pfoglobals_flex_abilities, ...pfoglobals_initiative_fields, ...pfoglobals_ac_ability_fields, ...pfoglobals_ac_fields, ...pfoglobals_babs_fields, ...pfoglobals_skill_fields, ...pfoglobals_atk_fields, ...pfoglobals_spell_fields, ...pfoglobals_concentration_fields, ...pfoglobals_spells_dc_fields, ...pfoglobals_encumbrance_fields, ...pfoglobals_speed_fields, ...pfoglobals_conditions);
        let fixed_fields = Array.from(new Set(tmpfields)), all_fields = get_repsec_fields(repsec_agr, fixed_fields);
        getAttrs(all_fields, v => {
            if ("1" == (v.npc || "0")) return;
            let big_update = {}, update = {}, skills_array = [];
            _.each(repsec_agr.filter(current_section => "skill" == current_section.section.substr(0, 5)), repsec => { skills_array.push(...repsec.ids.map(id => `repeating_${repsec.section}_${id}`)) }), update = calc_conditions(v, objoptions.reset_conditions), _.extend(big_update, update), _.extend(v, update), update = calc_buffs(repsec_agr.filter(current_section => "buff" == current_section.section), v, objoptions.reset_buffs, skills_array), _.extend(big_update, update), _.extend(v, update), ["strength", "all"].includes(ability) && ("1" != v.npc && (update = calc_ability("strength", v), _.extend(big_update, update), _.extend(v, update)), update = calc_ability_mod("strength", v), _.extend(big_update, update), _.extend(v, update), "1" != v.npc && (update = calc_encumbrance(v), _.extend(big_update, update), _.extend(v, update), update = calc_speed(v), _.extend(big_update, update), _.extend(v, update))), ["dexterity", "all"].includes(ability) && ("1" != v.npc && (update = calc_ability("dexterity", v), _.extend(big_update, update), _.extend(v, update)), update = calc_ability_mod("dexterity", v), _.extend(big_update, update), _.extend(v, update)), ["constitution", "all"].includes(ability) && ("1" != v.npc && (update = calc_ability("constitution", v), _.extend(big_update, update), _.extend(v, update)), update = calc_ability_mod("constitution", v), _.extend(big_update, update), _.extend(v, update)), ["intelligence", "all"].includes(ability) && ("1" != v.npc && (update = calc_ability("intelligence", v), _.extend(big_update, update), _.extend(v, update)), update = calc_ability_mod("intelligence", v), _.extend(big_update, update), _.extend(v, update)), ["wisdom", "all"].includes(ability) && ("1" != v.npc && (update = calc_ability("wisdom", v), _.extend(big_update, update), _.extend(v, update)), update = calc_ability_mod("wisdom", v), _.extend(big_update, update), _.extend(v, update)), ["charisma", "all"].includes(ability) && ("1" != v.npc && (update = calc_ability("charisma", v), _.extend(big_update, update), _.extend(v, update)), update = calc_ability_mod("charisma", v), _.extend(big_update, update), _.extend(v, update)), update = calc_pc_size(v.size), _.extend(big_update, update), _.extend(v, update), update = {}, _.each(pfoglobals_flex_abilities, ablt => { update[`${ablt}_mod`] = v[`${v[ablt]}_mod`] }), _.extend(big_update, update), _.extend(v, update), big_update.hp = (parseInt(v.hp_base) || 0) + (parseInt(v.hp_condition) || 0) + (parseInt(v.hp_bonus) || 0), big_update.hp_max = (parseInt(v.hp_base_max) || 0) + (parseInt(v.hp_condition) || 0) + (parseInt(v.hp_bonus) || 0), big_update.hp_mod = (parseInt(v.hp_condition) || 0) + (parseInt(v.hp_bonus) || 0), parseInt(big_update.hp_mod) > 0 ? big_update.hp_mod_flag = 2 : parseInt(big_update.hp_mod) < 0 ? big_update.hp_mod_flag = 1 : big_update.hp_mod_flag = 0, update = calc_initiative(v), _.extend(big_update, update), _.extend(v, update), update = calc_ac_ability(ability, v), _.extend(big_update, update), _.extend(v, update), update = calc_ac(v), _.extend(big_update, update), _.extend(v, update), update = calc_babs_all(v), _.extend(big_update, update), _.extend(v, update), _.each(["fortitude", "reflex", "will"], savename => { update = calc_save(savename, v), _.extend(big_update, update), _.extend(v, update) }), update = calc_sr(v), _.extend(big_update, update), _.extend(v, update), "1" == v.caster1_flag && (update = calc_concentration("caster1", v), _.extend(big_update, update), _.extend(v, update), update = calc_spells_dc("caster1", v, 0, 10), _.extend(big_update, update), _.extend(v, update)), "1" == v.caster2_flag && (update = calc_concentration("caster2", v), _.extend(big_update, update), _.extend(v, update), update = calc_spells_dc("caster2", v, 0, 10), _.extend(big_update, update), _.extend(v, update)), update = calc_skillranks_total(v), _.extend(big_update, update), skills_array.push(...pfoglobals_skill_list), update = calc_skill(skills_array, v, !0), _.extend(big_update, update), _.extend(v, update), _.extend(big_update, calc_damage_bonus_flag(v)), update = calc_attacks(repsec_agr.filter(current_section => "attacks" == current_section.section), v, "all"), _.extend(big_update, update), "1" != v.caster1_flag && "1" != v.caster2_flag || (update = calc_spells(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "like"], repsec_agr.filter(current_section => "spell-" == current_section.section.substr(0, 6)), v, "all"), _.extend(big_update, update)), update = calc_traits(repsec_agr.filter(current_section => "abilities" == current_section.section), v), _.extend(big_update, update), setAttrs(big_update, { silent: !0 }, () => {
                var elapsed = new Date - debug_start;
                console.log("Pathfinder sheet updated (" + elapsed + ")"), callback && callback()
            })
        })
    })
}, get_repsec_ids = function (repsec_array, callback, repsec_agr) {
    let currsection = repsec_array.shift();
    currsection.section ? (repsec_agr = repsec_agr || [], getSectionIDs(`repeating_${currsection.section}`, itemsids => { repsec_agr.push({ section: currsection.section, ids: itemsids, attrs: currsection.attrs }), _.isEmpty(repsec_array) ? callback(repsec_agr) : get_repsec_ids(repsec_array, callback, repsec_agr) })) : _.isEmpty(repsec_array) ? callback(repsec_agr) : get_repsec_ids(repsec_array, callback, repsec_agr)
}, get_repsec_fields = function (repsec_agr, other_attrs = []) {
    let fields = [], repsecfields = [];
    return _.each(repsec_agr, current_section => { _.each(current_section.ids, id => { _.each(current_section.attrs, attr => { repsecfields.push(`repeating_${current_section.section}_${id}_${attr}`) }) }) }), fields = repsecfields.concat(other_attrs)
}, toTitleCase = function (str) { return str.replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase() }) }, erase_repsec_ids = function (sectionArray, callback) {
    let thisSection = sectionArray.shift();
    getSectionIDs(thisSection, itemids => { _.each(itemids, item => { removeRepeatingRow(`repeating_${thisSection}_${item}`) }), sectionArray.length > 0 ? erase_repsec_ids(sectionArray, callback) : callback() })
}, parse_formula = function (formula, v) {
    if ((formula || "").length) {
        let value = 0, trslate = (formula || "").replace(/\[[\w\s]+\]/gi, "").replace(/\[\[/g, "(").replace(/\]\]/g, ")").replace(/[\[\]]*/g, "").replace(/(floor|ceil|abs|round|max|min)\(/g, "Math.$1(").replace(/@{([^}]+)}/g, (match, p1) => parseInt(v[p1.toLowerCase()]) || 0);
        try { value = eval(trslate) } catch (error) { console.log("*** DEBUG parse_formula: " + formula + " -> " + trslate + " -error-> " + error) } return value
    } return 0
}, parse_compendium_formula = function (formula = "", caster = "1", inline = !1) {
    let fnl = "" + formula.trim();
    if (formula && formula.length) {
        let zereg, regreparr = [{ reg: "(\\d+)(d\\d+)([^$,\\.]*per\\s+caster\\s+level\\s+\\([^\\)]*maximum\\s+)(\\d+)(d\\d+\\))", mod: "gi", ori: "$1$2$3$4$5", rep: `[[{($1*@{caster${caster}_level}),$4}kl1]]$2` }, { reg: "(\\d+)(d\\d+)([^$,\\.]*per\\s+two\\s+caster\\s+levels\\s+\\([^\\)]*maximum\\s+)(\\d+)(d\\d+\\))", mod: "gi", ori: "$1$2$3$4$5", rep: `[[{($1*[[{floor((@{caster${caster}_level}/2)),1}kh1]]),$4}kl1]]$2` }, { reg: "(\\d+d\\d+)([^,\\.]*?(?=\\+))(\\+\\s*)(\\d+)(.+?(?=per))(per\\s+caster\\s+level\\s+\\(maximum\\s+\\+)(\\d+)(\\s*\\))", mod: "gi", ori: "$1$2$3$4$5$6$7$8", rep: `$1+{($4*@{caster${caster}_level}),$7}kl1` }, { reg: "(\\d+d\\d+)(\\s+rounds)", mod: "gi", ori: "$1$2", rep: "$1" }];
        _.each(regreparr, regrep => { zereg = new RegExp(regrep.reg, regrep.mod), fnl.match(zereg) && (fnl = inline ? fnl.replace(zereg, `${regrep.ori} ([[${regrep.rep}]])`) : fnl.replace(zereg, regrep.rep)) })
    } return fnl
}, calc_reset_character = function () {
    let update = {}, toResetAsChar = ["race", "class", "class1_name", "class2_name", "class3_name", "languages", "senses", "ac_notes", "fortitude_notes", "reflex_notes", "will_notes", "caster1_class", "caster2_class", "caster1_spells_notes", "caster2_spells_notes", "initiative_notes", "speed_notes", "encumbrance_display", "encumbrance_load_notes", "misc_notes", "background", "bab_notes", "cmb_notes", "melee_notes", "ranged_notes", "cmd_notes", "sr_notes", "craft_name", "perform_name", "profession_name", "npc_alignment", "aura", "hd_roll", "saves_modifiers", "defensive_abilities", "npc_type", "npc_dr", "immune", "resist", "weaknesses", "npc_speed", "space", "reach", "npc_spellabilities_notes", "npc_spells_notes", "tactics", "skills_racial_modifiers", "skills_notes", "sq", "combat_gear", "environment", "organization", "npcdrop_name", "npcdrop_uniq", "npcdrop_category", "npcdrop_data", "npc_icon_type", "npc_icon_terrain", "npc_icon_climate", "npc_cr", "npc_mr", "treasure"];
    toResetAsChar = (toResetAsChar = (toResetAsChar = toResetAsChar.concat(pfoglobals_abilities.map(ablt => `${ablt}_notes`))).concat(pfoglobals_skill_list.map(sk => `${sk}_notes`))).concat(pfoglobals_skill_list.map(sk => `${sk}_display`)), _.each(toResetAsChar, attr => { update[attr] = "" });
    for (var toResetAsZero = ["hp_base", "hp_base_max", "hp", "hp_max", "mancer_confirm_flag", "caster_flag", "class1_level", "class2_level", "class3_level", "money_cp", "money_sp", "money_gp", "money_pp", "xp", "sr", "spells_flag", "spellabilities_flag"], i = 1;
        i < 4;
        i++)toResetAsZero.push(`class${i}_bab`, `class${i}_fortitude`, `class${i}_reflex`, `class${i}_will`, `class${i}_skillranks_base`, `class${i}_speed`);
    for (var j = 1;
        j < 3;
        j++)for (i = 0;
            i < 10;
            i++)toResetAsZero.push(`caster${j}_spells_known_level_${i}`, `caster${j}_spells_perday_level_${i}`, `caster${j}_spells_bonus_level_${i}`, `caster${j}_spells_prepared_level_${i}`, `caster${j}_spells_total_level_${i}`, `caster${j}_dc_level_${i}`, `caster${j}_dcbonus_level_${i}`, `caster_spells_flag_level_${i}`);
    toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = (toResetAsZero = toResetAsZero.concat(pfoglobals_abilities.map(ablt => `${ablt}_race`))).concat(pfoglobals_abilities.map(ablt => `${ablt}_bonus`))).concat(pfoglobals_abilities.map(ablt => `${ablt}_condition`))).concat(pfoglobals_skill_list)).concat(pfoglobals_skill_list.map(sk => `${sk}_classkill`))).concat(pfoglobals_skill_list.map(sk => `${sk}_ability_mod`))).concat(pfoglobals_skill_list.map(sk => `${sk}_ranks`))).concat(pfoglobals_skill_list.map(sk => `${sk}_misc`))).concat(pfoglobals_skill_list.map(sk => `${sk}_bonus`))).concat(pfoglobals_skill_list.map(sk => `${sk}_flag`))).concat(pfoglobals_mods, ["initiative", "initiative_misc", "initiative_bonus"], ["fortitude", "fortitude_base", "fortitude_ability_mod", "fortitude_misc", "fortitude_bonus", "reflex", "reflex_base", "reflex_ability_mod", "reflex_misc", "reflex_bonus", "will", "will_base", "will_ability_mod", "will_misc", "will_bonus"], ["encumbrance_ability_maximum"], ["ac_condition_nobonus", "ac_bonus", "ac_ability_mod", "ac_armor", "ac_shield", "ac_size", "ac_natural_items", "ac_deflection_items", "ac_misc", "ac_dodge_items", "ac_touch_items", "ac_flatfooted_items", "ac_natural_bonus", "ac_deflection_bonus", "ac_dodge_bonus", "ac_noflatflooted", "ac_touchshield", "ac_condition", "ac_secab_monk", "ac_ff_ability_mod"], ["bab", "bab_max", "bab_multi", "bab_size", "cmb_mod", "cmb_size", "cmb_ability_mod", "cmb_misc", "cmb_bonus", "melee_mod", "melee_ability_mod", "melee_misc", "melee_bonus", "ranged_mod", "ranged_ability_mod", "ranged_misc", "ranged_bonus", "cmd_misc", "cmd_bonus", "cmd_condition", "fob", "fob_multi"], pfoglobals_skill_fields, ["caster1_flag", "caster2_flag", "caster1_level", "caster1_ability_mod", "caster1_concentration", "caster1_concentration_misc", "caster1_concentration_bonus", "caster2_level", "caster2_ability_mod", "caster2_concentration", "caster2_concentration_misc", "caster2_concentration_bonus"], ["encumbrance_load_bonus", "stealth_size", "encumbrance_size", "fly_size", "encumbrance_gear_weight", "encumbrance_load_light", "encumbrance_load_medium", "encumbrance_load_heavy", "encumbrance"], ["encumbrance", "speed_notmodified", "speed_bonus", "speed_condition_multiplier", "speed_condition_norun", "speed_condition_nospeed", "speed_class"], pfoglobals_conditions, ["armor_spell_failure", "caster1_dc_misc", "caster2_dc_misc"]), toResetAsZero = _.uniq(toResetAsZero), _.each(toResetAsZero, attr => { update[attr] = 0 });
    return _.each(["class1_level", "level", "class_favored", "encumbrance_load_multiplier", "caster1_spell_failure", "caster2_spell_failure", "meleeattacks_flag", "rangedattacks_flag", "specialattacks_flag", "special_abilities_flag", "ecology_flag"], attr => { update[attr] = 1 }), _.each(pfoglobals_abilities, ablt => { update[ablt] = 10, update[ablt + "_base"] = 10 }), update.alignment = "neutral", update.size = "medium", update.ac = 10, update.ac_touch = 10, update.ac_flatfooted = 10, update.class1_hitdietype = 8, update.class2_hitdietype = 8, update.class3_hitdietype = 8, update.xp_max = 2e3, update.encumbrance_run_factor = 4, update.armor_run_factor = 4, update.ac_ability_primary = "dexterity", update.ac_ability_secondary = "", update.ac_ability_maximum = "-", update.fortitude_ability = "constitution", update.reflex_ability = "dexterity", update.will_ability = "wisdom", update.cmb_ability = "strength", update.melee_ability = "strength", update.ranged_ability = "dexterity", update.cmd_mod = 10, update.speed = 30, update.speed_race = 30, update.speed_base = 30, update.speed_character = 30, update.speed_encumbrance = 30, update.speed_armor = 30, update.speed_run_factor = 4, update.speed_run = 120, update.speed_swim = 7.5, update.speed_climb = 7.5, update.encumbrance_load_light = 33, update.encumbrance_load_medium = 66, update.encumbrance_load_heavy = 100, update.encumbrance_lift_head = 100, update.encumbrance_lift_ground = 200, update.encumbrance_drag_push = 500, update.encumbrance_check_penalty = 0, update.encumbrance_ability_maximum = "-", update.encumbrance_run_factor = 4, update.encumbrance_coins_weight = 0, update.acrobatics_ability = "dexterity", update.appraise_ability = "intelligence", update.bluff_ability = "charisma", update.climb_ability = "strength", update.craft_ability = "intelligence", update.diplomacy_ability = "charisma", update.disable_device_ability = "dexterity", update.disguise_ability = "charisma", update.escape_artist_ability = "dexterity", update.fly_ability = "dexterity", update.handle_animal_ability = "charisma", update.heal_ability = "wisdom", update.intimidate_ability = "charisma", update.knowledge_arcana_ability = "intelligence", update.knowledge_dungeoneering_ability = "intelligence", update.knowledge_engineering_ability = "intelligence", update.knowledge_geography_ability = "intelligence", update.knowledge_history_ability = "intelligence", update.knowledge_local_ability = "intelligence", update.knowledge_nature_ability = "intelligence", update.knowledge_nobility_ability = "intelligence", update.knowledge_planes_ability = "intelligence", update.knowledge_religion_ability = "intelligence", update.linguistics_ability = "intelligence", update.perception_ability = "wisdom", update.perform_ability = "charisma", update.profession_ability = "wisdom", update.ride_ability = "dexterity", update.sense_motive_ability = "wisdom", update.sleight_of_hand_ability = "dexterity", update.spellcraft_ability = "intelligence", update.stealth_ability = "dexterity", update.survival_ability = "wisdom", update.swim_ability = "strength", update.use_magic_device_ability = "charisma", update.acrobatics_armor_penalty = "1", update.climb_armor_penalty = "1", update.disable_device_armor_penalty = "1", update.escape_artist_armor_penalty = "1", update.fly_armor_penalty = "1", update.ride_armor_penalty = "1", update.sleight_of_hand_armor_penalty = "1", update.stealth_armor_penalty = "1", update.swim_armor_penalty = "1", update.caster1_ability = "intelligence", update.caster2_ability = "intelligence", update
}, check_l1_mancer = function () {
    getAttrs(["l1mancer_status", "npc", "charactermancer_step"], function (v) {
        if ("1" != v.npc) {
            if (v.l1mancer_status && "completed" == v.l1mancer_status) return;
            v.charactermancer_step ? startCharactermancer(v.charactermancer_step) : v.l1mancer_status && "relaunch" == v.l1mancer_status ? startCharactermancer("l1-welcome") : setAttrs({ mancer_confirm_flag: 1 }, { silent: !0 })
        }
    })
}, initializeChar = function (doneupdating) {
    getAttrs(["character_name", "npc"], v => {
        if (console.log("Initializing character " + v.character_name), "1" != (v.npc || "0")) {
            let update = calc_reset_character();
            update.version = pfoglobals_currentversion, update.initialize_character_flag = 0, setAttrs(update, { silent: !0 }, () => { doneupdating() })
        } else setAttrs({ initialize_character_flag: 0, version: pfoglobals_currentversion }, { silent: !0 })
    })
}, update_to_1_07 = function (doneupdating) { console.log("UPDATING TO v1.07"), setAttrs({ ac_natural_bonus: 0, ac_deflection_bonus: 0, ac_dodge_bonus: 0 }, { silent: !0 }, () => { doneupdating() }) }, update_to_1_08 = function (doneupdating) {
    console.log("UPDATING TO v1.08"), getAttrs(["ac_ability_mod", "npc"], v => {
        if ("1" != (v.npc || "0")) {
            var update = {}, mod = 0;
            v.ac_ability_mod && (mod = v.ac_ability_mod), update.ac_ability_mod = mod, update.encumbrance_coins_weight = 0, setAttrs(update, { silent: !0 }, () => { update_ac(), update_babs_all(), update_all_spells("all"), update_coins_weight(), update_gear_weight_total(), update_encumbrance(), doneupdating() })
        } else doneupdating()
    })
}, update_to_1_10 = function (doneupdating) {
    console.log("UPDATING TO v1.10"), getAttrs(["dexterity", "hp", "hp_max", "npc"], v => {
        if ("1" != (v.npc || "0")) {
            var update = {}, mod = Math.floor(((parseInt(v.dexterity) || 10) - 10) / 2);
            update.dexterity_half_mod = Math.floor(.5 * mod), update.dexterity_oneandahalf_mod = Math.floor(1.5 * mod), update.hp_base = parseInt(v.hp) || 0, update.hp_base_max = parseInt(v.hp_max) || 0, setAttrs(update, { silent: !0 }, () => { update_cmd(), update_attacks("all"), update_all_spells("all"), doneupdating() })
        } else doneupdating()
    })
}, update_to_1_12 = function (doneupdating) { console.log("UPDATING TO v1.12"), getAttrs(["npc"], v => { "1" != (v.npc || "0") && update_all_skills(), doneupdating() }) }, update_to_1_14 = function (doneupdating) { console.log("UPDATING TO v1.14"), getAttrs(["npc", "size"], v => { "1" != (v.npc || "0") && setAttrs(calc_pc_size(v.size), { silent: !0 }, () => { update_babs_all() }), doneupdating() }) }, update_to_1_16 = function (doneupdating) { console.log("UPDATING TO v1.16"), getAttrs(["npc", "class", "race"], v => { "1" != (v.npc || "0") ? (update_speed(), v.class && v.class.trim().length || v.race && v.race.trim().length ? setAttrs({ l1mancer_status: "completed" }, { silent: !0 }, () => { doneupdating() }) : doneupdating()) : doneupdating() }) }, update_to_1_17 = function (doneupdating) {
    console.log("UPDATING TO v1.17"), getAttrs(["npc", "class_favored", "l1mancer_status"], v => {
        if ("1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed")) {
            let update = {}, fav = parseInt(v.class_favored) || 0;
            for (let i = 1;
                i < 4;
                i++)update["class" + i + "_favored"] = fav == i ? 1 : 0;
            setAttrs(update, { silent: !0 }, () => { update_skillranks_total(), doneupdating() })
        } else doneupdating()
    })
}, update_to_1_18 = function (doneupdating) { console.log("UPDATING TO v1.18"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") && update_skillranks_total(), doneupdating() }) }, update_to_1_19 = function (doneupdating) { console.log("UPDATING TO v1.19"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") && update_babs_all(), doneupdating() }) }, update_to_1_20 = function (doneupdating) {
    console.log("UPDATING TO v1.20"), getAttrs(["npc", "l1mancer_status", "ac_natural_bonus", "ac_deflection_bonus", "ac_dodge_bonus", "ac_natural", "ac_deflection", "ac_dodge", "hp_condition"], v => {
        if ("1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed")) {
            var update = { ac_armor_bonus: 0, ac_shield_bonus: 0 };
            v.ac_natural && (update.ac_natural_bonus = parseInt(v.ac_natural) || 0, update.ac_natural = 0), v.ac_deflection && (update.ac_deflection_bonus = parseInt(v.ac_deflection) || 0, update.ac_deflection = 0), v.ac_dodge && (update.ac_dodge_bonus = parseInt(v.ac_dodge) || 0, update.ac_dodge = 0), update.hp_mod = parseInt(v.hp_condition) || 0, update.hp_mod_flag = 0 == (parseInt(v.hp_condition) || 0) ? 0 : 1, setAttrs(update, { silent: !0 }, () => { update_ac_items(), update_attacks("all"), update_all_spells("all"), doneupdating() })
        } else "1" == v.npc ? (update_all_spells("all"), doneupdating()) : doneupdating()
    })
}, update_to_1_21 = function (doneupdating) {
    console.log("UPDATING TO v1.21"), getAttrs(["npc", "l1mancer_status"], v => {
        "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? getSectionIDs("repeating_buff", buffarray => {
            getSectionIDs("repeating_abilities", abltarray => {
                getSectionIDs("repeating_spell-like", splarray => {
                    let fields = [];
                    buffarray.length && (fields = fields.concat(...buffarray.map(id => `repeating_buff_${id}_mods`))), abltarray.length && (fields = fields.concat(...abltarray.map(id => `repeating_abilities_${id}_perday_max`))), splarray.length && (fields = fields.concat(...splarray.map(id => `repeating_spell-like_${id}_perday_max`))), fields.push("speed_climb", "speed_swim"), getAttrs(fields, valz => {
                        let update = {};
                        update.speed_climb_base = valz.speed_climb, update.speed_swim_base = valz.speed_swim, _.each(buffarray, id => {
                            update[`repeating_buff_${id}_mods`] = valz[`repeating_buff_${id}_mods`].replace(/\,/g, ";
") }), _.each(abltarray, id => { update[`repeating_abilities_${id}_perday_qty`] = valz[`repeating_abilities_${id}_perday_max`] }), _.each(splarray, id => { update[`repeating_spell-like_${id}_perday_qty`] = valz[`repeating_spell-like_${id}_perday_max`] }), setAttrs(update, { silent: !0 }, () => { update_speed(), doneupdating() }) }) }) }) }) : doneupdating() }) }, update_to_1_22 = function (doneupdating) { console.log("UPDATING TO v1.22"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? le_big_stuff("all", {}, () => { doneupdating() }) : doneupdating() }) }, update_to_1_26 = function (doneupdating) { console.log("UPDATING TO v1.26"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? (update_spells("like", "all"), doneupdating()) : doneupdating() }) }, update_to_1_27 = function (doneupdating) { console.log("UPDATING TO v1.27"), getAttrs(["rollmod_attack", "rollmod_damage"], v => { update = {}, "rollmod_attack" in v && " ? {@{ ask_modifier } | 0}" == v.rollmod_attack && (update.rollmod_attack = " ? {@{ ask_atk_modifier } | 0}"), "rollmod_damage" in v && " ? {@{ ask_modifier } | 0}" == v.rollmod_damage && (update.rollmod_damage = " ? {@{ ask_dmg_modifier } | 0}"), setAttrs(update, { silent: !0 }, () => { doneupdating() }) }) }, update_to_1_28 = function (doneupdating) { console.log("UPDATING TO v1.28"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? (update_attacks("all"), doneupdating()) : doneupdating() }) }, update_to_1_29 = function (doneupdating) { console.log("UPDATING TO v1.29"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? getSectionIDs("repeating_acitems", idarray => { if (idarray.length) { let attrs = [];
 _.each(idarray, itemid => { attrs.push(`repeating_acitems_${itemid}_max_dex_bonus`) }), getAttrs(attrs, v => {
                                let update = {};
                                _.each(idarray, itemid => { `repeating_acitems_${itemid}_max_dex_bonus` in v && "0" == v[`repeating_acitems_${itemid}_max_dex_bonus`] && (update[`repeating_acitems_${itemid}_max_dex_bonus`] = "-") }), setAttrs(update, { silent: !0 }, () => { doneupdating() })
                            }) } else doneupdating() }) : doneupdating()
}) }, update_to_1_30 = function (doneupdating) { console.log("UPDATING TO v1.30"), getAttrs(["npc", "l1mancer_status", "sr"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? setAttrs({ sr_base: v.sr || "0" }, { silent: !0 }, () => { update_damage_bonus_flag(), doneupdating() }) : doneupdating() }) }, update_to_1_301 = function (doneupdating) { console.log("UPDATING TO v1.301"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? (update_all_spells("all"), doneupdating()) : doneupdating() }) }, update_to_1_302 = function (doneupdating) { console.log("UPDATING TO v1.302"), getAttrs(["npc", "l1mancer_status"], v => { "1" != (v.npc || "0") && "completed" == (v.l1mancer_status || "completed") ? (update_attacks("all"), doneupdating()) : doneupdating() }) }, versioning = function () {
    getAttrs(["version"], v => {
        let vrs = parseFloat(v.version) || 0;
        vrs === pfoglobals_currentversion ? (console.log("Pathfinder by Roll20 v" + vrs), check_l1_mancer()) : vrs < 1 ? setAttrs({ initialize_character_flag: 1 }, () => { initializeChar(() => { versioning() }) }) : vrs < 1.07 ? update_to_1_07(() => { setAttrs({ version: "1.07" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.08 ? update_to_1_08(() => { setAttrs({ version: "1.08" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.1 ? update_to_1_10(() => { setAttrs({ version: "1.10" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.12 ? update_to_1_12(() => { setAttrs({ version: "1.12" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.14 ? update_to_1_14(() => { setAttrs({ version: "1.14" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.16 ? update_to_1_16(() => { setAttrs({ version: "1.16" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.17 ? update_to_1_17(() => { setAttrs({ version: "1.17" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.18 ? update_to_1_18(() => { setAttrs({ version: "1.18" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.19 ? update_to_1_19(() => { setAttrs({ version: "1.19" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.2 ? update_to_1_20(() => { setAttrs({ version: "1.20" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.21 ? update_to_1_21(() => { setAttrs({ version: "1.21" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.22 ? update_to_1_22(() => { setAttrs({ version: "1.22" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.26 ? update_to_1_26(() => { setAttrs({ version: "1.26" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.27 ? update_to_1_27(() => { setAttrs({ version: "1.27" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.28 ? update_to_1_28(() => { setAttrs({ version: "1.28" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.29 ? update_to_1_29(() => { setAttrs({ version: "1.29" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.3 ? update_to_1_30(() => { setAttrs({ version: "1.30" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.301 ? update_to_1_301(() => { setAttrs({ version: "1.301" }, { silent: !0 }, () => { versioning() }) }) : vrs < 1.302 ? update_to_1_302(() => { setAttrs({ version: "1.302" }, { silent: !0 }, () => { versioning() }) }) : setAttrs({ version: pfoglobals_currentversion }, { silent: !0 }, () => { versioning() })
    })
};
return { calc_npc_skill_display: calc_npc_skill_display, check_l1_mancer: check_l1_mancer, pc_drop_handler: pc_drop_handler, drop_add_feats: drop_add_feats, drop_add_spellike: drop_add_spellike, drop_add_spells: drop_add_spells, pc_drop_spell: pc_drop_spell, le_big_stuff: le_big_stuff, mancer_finish: mancer_finish, reset_to_xpc: reset_to_xpc, sheet_open: sheet_open, update_ac: update_ac, update_ac_ability: update_ac_ability, update_ac_items: update_ac_items, update_all_skills: update_all_skills, update_all_spells: update_all_spells, update_attacks: update_attacks, update_traits: update_traits, update_babs: update_babs, update_babs_all: update_babs_all, update_class_names: update_class_names, update_class_numbers: update_class_numbers, update_cmd: update_cmd, update_coins_weight: update_coins_weight, update_concentration: update_concentration, update_default_token: update_default_token, update_encumbrance: update_encumbrance, update_gear_weight: update_gear_weight, update_gear_weight_total: update_gear_weight_total, update_hitdie: update_hitdie, update_initiative: update_initiative, update_mod: update_mod, update_npc_attack: update_npc_attack, update_npc_drop: update_npc_drop, update_save: update_save, update_size: update_size, update_skill: update_skill, update_skillranks_total: update_skillranks_total, update_skills_ranks: update_skills_ranks, update_speed: update_speed, update_spells: update_spells, update_spells_dc: update_spells_dc, update_spells_flag: update_spells_flag, update_spells_prepared: update_spells_prepared, update_spells_totals: update_spells_totals, update_sr: update_sr, update_damage_bonus_flag: update_damage_bonus_flag } }();
</script >
